\chapter{Introdução}\label{chap-introduction}

Um sistema de controle digital consiste de sensores, sistema controlado, algoritmos de controle e atuadores, que juntos buscam manter o comportamento das variáveis de uma planta (sistema controlado) sob controle, ou seja, garantem as respostas desejadas de estado estacionário e transitório~\cite{boyd1991linear}.
O desenvolvimento de controladores digitais é uma tarefa fundamental na engenharia de controle, uma vez que eles são rotineiramente usados para muitas aplicações diferentes, que vão desde a indústria até no ramo aeroespacial~\cite{simons1994levers}.

A teoria de controle digital visa preservar algumas propriedades baseadas em modelos de tempo discreto, por exemplo, estabilidade e robustez, que são necessárias para a operação correta de plantas reais através de um controlador digital. Controlar sistemas contínuos usando controladores digitais levanta problemas típicos de sistemas híbridos.
Além disso, arredondamento e quantização de amostras e coeficientes em controladores digitais, devido a implementações de comprimento de palavras finitas (\textit{finite word length} - FWL), podem levar a \textit{overflow}, oscilação de ciclo limite e sensibilidade a polos e zeros, o que pode causar instabilidade do sistema e degradação do desempenho~\cite{istepanian2012digital,BessaICF16,bessa2017formal}. De fato, esse tipo de sensibilidade é chamado de fragilidade~\cite{keel1997robust} e é importante para o projeto de sistemas de controle, uma vez que está diretamente relacionado à sua robustez. Na literatura, existem alguns estudos relacionados que consideram perturbações nas implementações de sistemas de controle; Yordanov \textit{et al.} \cite{yordanov2012temporal} considera pequenas perturbações nas entradas aplicadas em um sistema dinâmico para a síntese de uma estratégia de controle de realimentação para um sistema de afinidade por partes (PWA) em tempo discreto a partir de uma especificação dada como uma fórmula de lógica linear temporal (LTL) sobre um conjunto de predicados lineares nas variáveis de estado do sistema.

Algumas iniciativas que utilizam a verificação formal aplicada a sistemas de controle dinâmicos foram desenvolvidas nos últimos anos. Por exemplo, Bessa \textit{et al.} \cite{bessa2017formal} apresentam um método de verificação para determinar a estabilidade incerta do sistema linear em relação aos controladores digitais, levando em conta aspectos de implementação, enquanto Wang \textit{et al.}, ampliam as técnicas tradicionais de verificação para implementação de controladores digitais, com o objetivo de abordar a validação da robustez no modelo e no nível de código. Abreu \textit{et al.} \cite{abreu2016bounded} desenvolvem um método para verificar filtros digitais relativos a \textit{overflow} e ruído indesejado, que são causados por efeitos de quantização e arredondamento, e Belta~\cite{belta2014formal} verificaram a estabilidade em sistemas dinâmicos. Além disso, Racchetti \textit{et al.}~\cite{racchetti2015verification} geraram sequências de teste a partir de diagramas temporais de especificações de \textit{software} e as executaram em tempo real, verificou-se parte de sua conformidade, salvou-se contornos de teste e analisou-os automaticamente através de um método de verificação.
Nilsson \textit{et al.}~\cite{nilsson2016correct} aplicam métodos formais de controle de cruzeiro adaptativo e executa síntese de controlador que é correta por construção.

Em sistemas de controle, parâmetros de resposta a degraus são comumente usados para especificar um elemento de controle, a fim de indicar que um sistema de controle de malha fechada é seguro em relação às suas especificações de desempenho, ou seja, quando sua resposta ao degrau atende, por exemplo, especificações de tempo assentamento e sobressinal~\cite{franklin1998digital}.
 %
No entanto, existem alguns estudos relacionados que abordam parâmetros de desempenho com métodos formais.
Nesse sentido, Gross \textit{et al.} apresentam uma abordagem para formalizar requisitos comuns de sistemas de controle de atitude de naves espaciais, onde os tempos de assentamento são verificados através de testes de hipóteses \cite{gross2017formal}; Jin \textit{et al.} propõem uma estrutura baseada em métodos formais para capturar requisitos de modelos em malha fechada de sistemas de controle em escala industrial, incluindo tempo de assentamento e sobressinal \cite{jin2015mining}.
De fato, dado que perturbações ou mudanças em entradas pode levar a oscilações transitórias em saídas, é importante que estes últimos estejam dentro da região de assentamento, isto é, uma área especificando os desvios tolerados de uma dada referência, dentro de um tempo de assentamento especificado, e os sobressinais são menores do que um valor máximo requerido~\cite{jin2015mining}.

Também é importante reforçar que os efeitos FWL têm um grande impacto no comportamento do sistema~\cite{istepanian2012digital}. Geralmente, os controladores são fortemente influenciados por ligeiras imprecisões (por exemplo, erro de arredondamento e quantização), o que, em alguns casos, pode até levar à instabilidade. De fato, quando implementamos um sistema de controle em uma plataforma física (microcontroladores/microprocessadores), inevitavelmente lidamos com efeitos FLW, incluindo quantização de todos os resultados aritméticos (somas e produtos) e sinais de entrada, que afetam notavelmente alocalização dos polos e zeros~\cite{li1997pole}.

Como consequência, isso leva a um comportamento diferente, quando comparado com os requisitos de projeto, como se pode perceber ao longo deste trabalho e seus resultados. Além disso, vale notar que o tempo de assentamento e o sobressinal são requisitos típicos de projeto de sistemas de controle, o que leva a um comportamento específico de um sistema em desenvolvimento, juntamente com uma metodologia específica. Eles também são extremamente relacionados uns com os outros, embora sejam geralmente objetivos conflitantes~\cite{franklin1998digital}.

Geralmente, precisamos que nosso sistema se estabilize dentro de um certo período, com um sobressinal específico, e esse requisito revela prontamente a importância de verificar essas propriedades.
Nesse sentido, aplicações clínicas geralmente exigem o estabelecimento de especificações de projeto realistas \cite{walsh2013relationship} e, por exemplo, sistemas de malha fechada devem responder rápida e suavemente a mudanças nos pontos de referência da pressão arterial média (MAP), operação que normalmente é realizado por um anestesista, sem sobressinal excessivo; caso contrário, pode causar sérios problemas em um centro cirúrgico \cite{walsh2013relationship}.

Nos últimos anos, a literatura trouxe alguns trabalhos que abordam a síntese de programas, que é uma técnica usada para encontrar entidades que satisfaçam a intenção do usuário expressa em alguma forma de restrições \cite{jha2010oracle}. Uma técnica específica de síntese de programa chamada síntese indutiva guiada por contraexemplo (CEGIS) é uma abordagem que determina parâmetros desconhecidos dentro de programas parciais, de forma que os elementos resultantes satisfaçam algumas propriedades de correção~\cite{ravanbakhsh2015counter}. Alguns trabalhos foram feitos utilizando a técnica CEGIS para a realização de síntese, como a descrita por Abate \textit{et. al}, onde mostram os pontos fortes de um sintetizador indutivo guiado por contraexemplos comparado com a abordagem de um solucionador de teoria, explorando o espaço da solução de maneira mais eficiente sem depender da orientação do usuário~\cite{abate2018counterexample}.

Trabalhos que aplicam CEGIS para estabilizar controladores podem ser encontrados na literatura, como o descrito em \cite{ravanbakhsh2015counter} onde é investigado o problema de sintetizar controladores de comutação para estabilizar a planta de tempo contínuo; no entanto, em sistemas de controle, é importante cuidar dos requisitos de desempenho, como tempo de assentamento e sobressinal, a fim de satisfazer um comportamento específico~\cite{ogata2002modern}.

Problemas relativos a efeitos FWL na implementação de controladores digitais em plataformas do mundo real devem ser levados em consideração quando se projeta controladores digitais, conforme falado anteriormente nos trabalhos \cite{BessaICF16,bessa2017formal}. Portanto, deve-se considerar esses fatores quando se sintetiza controladores digitais para que o funcionamento do sistema ocorra de acordo com o esperado.

%Recentemente, tem sido mais comum o uso da tecnologia para lidar com diversas tarefas do dia-a-dia, cada uma com uma complexidade associada. Assegurar que sistemas funcionem apropriadamente implica diretamente em redução de custos e, em alguns casos, até em segurança de vidas~\cite{Ariane5}. Quando se trata de software, descobrir erros em software é uma atividade que precisa ser executada nos primeiros estágios do processo de desenvolvimento, fazendo da depuração de programas uma tarefa merecedora de bastante atenção. A depuração de programas é uma tarefa muito importante, mas também consumidora de bastante tempo, pois necessita de uma análise minuciosa para que erros sejam encontrados. Ela pode ser dividida em três passos: detecção de falhas, localização de falhas e correção de falhas. No entanto, é possível reduzir o tempo associado a essa tarefa drasticamente se métodos automáticos forem aplicados nesses passos. Vários métodos já foram propostos com o objetivo de encontrar erros em software, como o teste de software~\cite{Myers:2011} e métodos baseados em modelos~\cite{Mayer:2008,Tip:1995,Offutt:1996,He:2004,Cleve:2005,Friedrich:1996,Chaki:2004}. Mais precisamente, quando um erro é encontrado, a causa do mesmo deve ser rastreada dentro do código-fonte~\cite{Zeller:2009,RochaBCN12}.
%
%Programas concorrentes tem sido amplamente usados na área de sistemas embarcados devido ao menor tempo de resposta associado e o uso otimizado dos recursos computacionais disponíveis. No entanto, quando se trata de assegurar a corretude de tais programas, torna-se uma tarefa complexa, visto que o número de possíveis intercalações pode crescer exponencialmente com o número de {\it threads} e linhas de código. Desta forma, o processo de depuração nesta classe de programas torna-se uma tarefa exaustiva para desenvolvedores, ao ponto de até não serem descobertos defeitos no código~\cite{Godefroid:2008}.
%
%Em relação à detecção de falhas em programas concorrentes, a verificação de modelos vem se mostrando uma técnica eficaz. Devido à sua abordagem, a partir de um modelo de um sistema, {\it i.e.}, o código-fonte, ela gera um sistema de transição de estados e procura por um caminho que leve a uma violação de uma propriedade especificada. Com o intuito de explorar o sistema de transição de estados do modelo sem estourar os recursos computacionais disponíveis, o uso da verificação de modelos limitada (do inglês {\it bounded model checking}), tem sido usada para procurar por violações em códigos concorrentes, procurando por contraexemplos em uma profundidade $k$, produzindo uma fórmula mais simples de ser solucionada.
%
%Qadeer {\it et. al.}~\cite{Qadeer:2004} propuseram o uso de sequencialização, {\it i.e.}, transformações de código formulada com regras específicas, para simplificar a verificação de modelos de programas concorrentes, evitando o problema de crescimento exponencial da complexidade associada a esta tarefa. Desta forma, ao criar um programa sequencializado que representa o programa original com relação a uma determinada intercalação diminui o peso sobre o verificador de modelos na hora de buscar violações de propriedades a uma profundidade $k$. Apesar de não relatar falso-positivos, a técnica pode não encontrar alguns erros. Todavia, uma importante observação desta técnica foi que erros de concorrência geralmente se manifestam em poucas trocas de contexto~\cite{Qadeer:2004}.
%
%Em relação à etapa de localização de  linhas defeituosas, {\it i.e.}, que levam à uma execução mal-sucedida do código, a verificação de modelos por si só não é capaz de apontá-las diretamente, pois o contraexemplo mostra a sequência de estados do programa que levam à violação, sendo necessário uma análise precisa para tentar isolar essas linhas, nem sempre sendo possível. Porém, Clarke {\it et. al.}~\cite{Clarke:2003,Clarke:1995} e Rocha {\it et. al.}~\cite{RochaBCN12} citam que os contraexemplos contém de fato informações relevantes à localização de falhas.
%
%Griesmayer {\it et. al.}~\cite{Griesmayer:2007} discutem o uso de técnicas de verificação de modelos para produzir contraexemplos que informem não somente a existência de falhas mas também as suas respectivas localizações em códigos sequenciais, a ideia é instrumentar o código original e fazendo uso do não-determinismo para atribuir valores às variáveis do programa. Esta abordagem, no entanto, funciona apenas para programas sequenciais.
%
%Assim, quando se trata de localização de falhas em programas concorrentes, \textit{i.e.}, apontar as linhas envolvidas em execuções mal-sucedidas de um programa, os itens descritos anteriormente isolados não são capazes de abordar este problema de forma sistemática. Ao elaborar uma metodologia para abordar este problema com tais técnicas, reduz-se o tempo de depuração de programas concorrentes, auxiliando desenvolvedores de software na fase de implementação a encontrar defeitos complexos de forma menos exaustiva.

\section{Descrição do Problema}

Este trabalho visa resolver o problema levantado nos últimos parágrafos e apresenta uma técnica formal para sintetizar um controlador, avaliando os requisitos de desempenho em sistemas de controle digital, utilizando uma técnica baseada em CEGIS e algoritmos genéticos~\cite{deb2004introduction}, levando em consideração os efeitos FWL, que foi implementado em um verificador de modelo limitado chamado DSVerifier \cite{ismail2015dsverifier}.

Algoritmos genéticos são utilizados neste trabalho com o objetivo de gerar um controlador canditado que satisfaça aos requisitos de tempo de assentamento e sobressinal, sendo uma das etapas na metodologia de síntese desenvolvida. Nossa metodologia visa sintetizar um controlador que também satisfaça aos requisitos oriundos dos efeitos FWL.

%Este trabalho visa resolver o problema da localização de falhas em programas concorrentes utilizando técnicas de verificação de modelos limitada de forma automática. Para tanto, utilizaram-se as seguintes abordagens: ($1$) aplicação de uma gramática e regras de transformação para possibilitar a sequencialização de programas concorrentes e ($2$) uso de contraexemplos obtidos por um verificador de modelos para localizar falhas em tais programas.
%
%A primeira abordagem deriva do fato de programas concorrentes serem mais difíceis de serem verificados, devido ao problema de explosão de estados (o número de estados possíveis cresce exponencialmente de acordo com o número de {\it threads} e trocas de contexto possíveis). A segunda consiste em usar a verificação de modelos limitada para obter um contraexemplo para um programa sequencial não-determinístico instrumentado, com o objetivo de extrair do mesmo as linhas que levam a uma execução defeituosa do programa original.

Assim, o método proposto utiliza técnicas de síntese de programas, algoritmos genéticos e um verificador formal para verificar a validade do controlador sintetizado.

\section{Objetivos}

O principal objetivo deste trabalho é propor um método para sintetizar um controlador digital obedecendo requisitos de performance e levando a ação dos efeitos FWL nos controladores.

Os objetivos específicos são:

\begin{itemize}

\item Propor um metodologia formal para verificação de requisitos de performance, como tempo de assentamento e sobressinal.

\item Propor uma metodologia de síntese de controladores digitais, baseada na técnica CEGIS, utilizando algoritmos genéticos.

\item Avaliar experimentalmente o método proposto utilizando \textit{benchmarks} bastante diversificados, incluindo sitemas sintéticos, bem como sistemas do mundo real extraídos da literatura.

\end{itemize}

\section{Contribuições}

Este trabalho tem quatro principais contribuições. Primeiro, um método para sintetizar controlodores digitais utilizando a técnica de CEGIS levando em conta fragilidade e efeitos FWL nos controladores. Segundo, uma abordagem para gerar controladores candidatos que obedeçam a requisitos de performance através de algoritmos genéticos, como uma das etapas da síntese de controladores. Terceiro, como parte do método de síntese, propomos técnicas para verificar formalmente sistemas de controle digital, com respeito a requisitos de performance. Por último, de acordo com os conhecimentos obtidos neste trabalho e os resultados obtidos, o método apresentado é capaz de assistir engenheiros de controle no projeto e implementação de controladores digitais.

\section{Organização da Dissertação}

A dissertação está organizada da seguinte maneira: no Capítulo~\ref{chap_background} são apresentados os conceitos básicos de verificação formal, sistemas dinâmicos lineares, técnicas de projeto de controle para sistemas discreto e ao fim, falamos a respeito de implementação de controladores digiatais no mundo real; o Capítulo~\ref{chap_related_work} apresenta um resumo dos trabalhos relacionados à verificação formal aplicada à controladores de sistemas de controle, à síntese de controladores de sistemas de controle e no fim do capítulo, os trabalhos são comparados, salientando as principais diferenças entre a abordagem proposta neste trabalho em relação às existentes; o Capítulo~\ref{chap_methodology} descreve o método proposto para sintetizar controladores digitais, considerando aspecos de implementação, como os efeitos FWL; no Capítulo~\ref{chap_results} são apresentados os resultados experimentais feitos em um conjunto de \textit{benchmarks} e também é feita uma discussão dos resultados obtidos; e por fim o Capítulo~\ref{chap_conclusion} apresenta as conclusões do trabalho, além de apresentar sugestões para trabalhos futuros.

