\chapter{Fundamentação Teórica}\label{chap_background}

Neste capítulo, são apresentados os conceitos básicos utilizados durante o desenvolvimento desta dissertação. Primeiramente serão apresentados alguns conceitos importantes sobre verificação formal com o objetivo de chegar em invariantes. Em seguida, sobre representações de sistemas dinâmicos lineares (contínuos e discretos), discretização, e análise quantitativa da resposta ao degrau de sistemas dinâmicos. Também falaremos a respeito de técnicas de projeto de controle para sistemas discretos, em particular, cada técnica usada para comparação com a estratégia utilizada nesse trabalho: alocação de polos, LQR e CEGIS. Além disso, uma breve introdução a implementação de controladores digitais e efeitos de palavra finita. Por fim, um resumo do capítulo é dado, para sintetizar o conteúdo do mesmo.

\section{Verificação Formal}\label{sec:formal-verification}

A verificação formal é o processo de verificar se um projeto satisfaz alguns requisitos ou até mesmo propriedades. Normalmente, preocupa-se com a verificação formal de projetos que podem ser especificados hierarquicamente; isso também é consistente com a forma como um ser humano faria para projetar. Comumente, para verificar formalmente um projeto, ele deve primeiro ser convertido em um formato `verificável' mais simples. O projeto é especificado como um conjunto de sistemas de interação; cada um tem um número finito de configurações, chamado estados. Estados e transição entre estados constituem FSMs (\textit{Formal Specification Methods}). Todo o sistema é um FSM, que pode ser obtido compondo os FSMs associados a cada componente. Portanto, o primeiro passo na verificação consiste em obter uma descrição completa do sistema FSM. Dado um estado presente (ou configuração atual), o próximo estado (ou configuração sucessiva) de um FSM pode ser escrito como uma função de seu estado atual e entradas (função de transição ou relação de transição).

Nota-se que todo este \textit{framework} é uma das funções discretas. Funções discretas podem ser representadas convenientemente por BDDs (diagrama de decisão binária; uma estrutura de dados que representa funções booleanas (de 2 valores)) e seus MDDs de extensão (diagrama de decisão de múltiplos valores; uma estrutura de dados que representa funções discretas de valor finito). Usa-se BDDs e MDDs para representar todas as quantidades necessárias neste espaço discreto (mais especificamente as funções de transição, as entradas, as saídas e os estados dos FSMs). Para que os BDDs e MDDs sejam representações eficientes de funções discretas, uma boa ordenação de variáveis de entrada (entradas reais, saídas, estado) das funções deve ser calculada. Em geral, os BDDs operam em conjuntos de pontos em vez de pontos individuais; isso é chamado de manipulação simbólica.

Os dois métodos mais populares para verificação formal automática são a contenção de linguagem e a verificação de modelo.

\subsection{Verificação de Modelo de Lógica Temporal}\label{sec:mctl}

Um sistema de estados finitos pode ser representado por um grafo de transição de estado rotulado, onde rótulos de um estado são os valores de proposições atômicas naquele estado. Propriedades sobre o sistema são expressas como fórmulas em lógica temporal das quais o sistema de transição de estados deve ser um `modelo'. A verificação de modelos consiste em percorrer o grafo do sistema de transição e verificar se satisfaz a fórmula que representa a propriedade, isto é, o sistema é um modelo da propriedade.

\subsubsection{Lógica da Árvore de Computação}\label{subsec:ctl}

A lógica temporal expressa a ordenação de eventos no tempo por meio de operadores que especificam propriedades como ``$p$ eventualmente se manterá''. Existem várias versões da lógica temporal; uma é a lógica da árvore computacional (CTL). Árvores de computação são derivadas de grafos de transição de estado. A estrutura do grafo é desenrolada em uma árvore infinita com raiz no estado inicial. A Figura~\ref{figure:tree} mostra um exemplo de desenrolamento de um grafo em uma árvore. Os caminhos nesta árvore representam todos os cálculos possíveis do sistema que está sendo modelado. Fórmulas em CTL referem-se à árvore de cálculo derivada do modelo. O CTL é classificado como uma lógica de tempo de ramificação porque possui operadores que descrevem a estrutura de ramificação dessa árvore.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.35]{figures/Tree}
  \caption{Desenrolamento do grafo de transição de estado.}
  \label{figure:tree}
\end{figure}

Fórmulas em CTL são construídas a partir de proposições atômicas (onde cada proposição corresponde a uma variável no modelo), conectivos booleanos padrão de lógica proposicional (por exemplo, e ($\lor$), ou ($\wedge$), ou-exclusivo($\veebar$), negação ($\lnot$)) e operadores temporais. Cada operador temporal consiste em duas partes: um quantificador de caminho (\textbf{A} ou \textbf{E}) seguido por uma modalidade temporal (\textbf{F}, \textbf{G}, \textbf{X}, \textbf{U}). Todos os operadores temporais são interpretados em relação a um estado atual implícito. Existem, em geral, muitos caminhos de execução (sequências de transições de estado) do sistema, começando no estado atual. O quantificador de caminho indica se a modalidade define uma propriedade que deve ser verdadeira para todos os caminhos possíveis (denotada pelo quantificador de caminho universal \textbf{A}) ou se a propriedade precisa apenas de algum caminho (denotado pelo quantificador de caminho existencial \textbf{E}). As modalidades temporais descrevem a ordenação de eventos no tempo ao longo de um caminho de execução e têm o seguinte significado intuitivo:

\begin{enumerate}
\item $\textbf{F}\phi$ (lê-se ``$\phi$ vale no futuro'') é verdadeiro de um caminho se existir um estado no caminho onde a fórmula $\phi$ é verdadeira;
\item $\textbf{G}\phi$ (lê-se ``$\phi$ vale globalmente'') é verdadeiro de um caminho se $\phi$ for verdadeiro em todos os estados no caminho;
\item $\textbf{X}\phi$ (lê-se ``$\phi$ vale no próximo estado'') é verdadeiro de um caminho se $\phi$ é verdadeiro no estado alcançado imediatamente após o estado atual no caminho;
\item $\phi\textbf{U}\psi$ (lê-se ``$\phi$ vale enquanto $\psi$ vale'', chamado ``forte até'') é verdadeiro de um caminho se $\psi$ for verdadeiro em algum estado no caminho, e $\phi$ é válido em todos os estados anteriores.
\end{enumerate}

Cada fórmula da lógica é verdadeira ou falsa em um determinado estado; sua verdade é avaliada a partir da verdade de suas subfórmulas de forma recursiva, até chegar a proposições atômicas que são verdadeiras ou falsas em um dado estado. Uma fórmula é satisfeita por um sistema se for verdadeira para todos os estados iniciais do sistema. Se a propriedade não for válida, o verificador de modelo produzirá um contraexemplo, que é um caminho de execução que testemunha a falha. Um algoritmo eficiente para verificação automática de modelos foi descrito por Clarke \textit{et al.}~\cite{Clarke:1995}. A tabela a seguir mostra exemplos de avaliações de fórmulas na árvore de computação da Figura~\ref{figure:tree}:

\begin{table}[htb]
	\renewcommand{\arraystretch}{1.0}
	\caption{Exemplos de avaliações de fórmulas na arvore de computação mostrada.}
	\label{table:ctl}
	\centering
	\begin{tabular}{c|c}
		\hline \bfseries Fórmula & \bfseries T/F\\
		\hline $\textbf{EG} (RED)$ & $True$\\
		\hline $\textbf{E} (RED \cup GREEN)$ & $True$\\
		\hline $\textbf{AF}(GREEN)$ & $False$\\
		\hline
	\end{tabular}
\end{table}

\subsubsection{Contenção de Linguagem}\label{subsec:lc}

Existem propriedades de interesse prático que não podem ser descritas no CTL. Um exemplo é a propriedade ``quase sempre'': uma condição, ${\displaystyle \mathbf{q}}$, sempre se mantém após um número finito de transições (note que as fórmulas ${\displaystyle \mathbf{F}}{\displaystyle \mathbf{G}}$ ${\displaystyle \mathbf{q}}$ e ${\displaystyle \mathbf{A}}{\displaystyle \mathbf{F}}{\displaystyle \mathbf{G}}$ ${\displaystyle \mathbf{q}}$ expressariam isso, mas estas não são fórmulas legais de CTL). Esta propriedade se parece muito com ${\displaystyle \mathbf{A}}{\displaystyle \mathbf{F}}$ ${\displaystyle \mathbf{A}}{\displaystyle \mathbf{G}}$ ${\displaystyle \mathbf{q}}$, mas não é o mesmo. Pode-se exibir um sistema de transição onde ${\displaystyle \mathbf{A}}{\displaystyle \mathbf{F}}$ ${\displaystyle \mathbf{G}}$ ${\displaystyle \mathbf{q}}$ é verdadeiro, enquanto ${\displaystyle \mathbf{A}}{\displaystyle \mathbf{F}}$ ${\displaystyle \mathbf{A}}{\displaystyle \mathbf{G}}$ ${\displaystyle \mathbf{q}}$ é falso.
 
Uma solução seria usar um tipo mais expressivo de lógica temporal (por exemplo, a propriedade anterior poderia ser expressa em Propositional Linear Temporal Logic (PLTL) ou CTL). Porém haveria desvantagens, como a maior complexidade de algoritmos para verificação de modelos. Uma alternativa é usar outro paradigma de verificação, chamado contenção de linguagem, baseado na teoria dos $\omega$-autômatos. Por exemplo, é fácil expressar a propriedade ``quase sempre'' anterior usando um autômato.

Para alcançar a verificação de contenção de linguagem, representamos a composição do sistema dado com um modelo que representa a negação da propriedade e verificamos o vazio da linguagem. A linguagem do sistema composto está vazia se e somente se o sistema satisfizer a propriedade ${\displaystyle \mathbf{T}}$.
 
O vazio de linguagem é usado não apenas para verificar as propriedades que não podem ser expressas em \textit{Fair} CTL, mas também para verificar se a abstração de um sistema ainda contém o sistema original. Em ambos os casos, é preciso complementar um $\omega$-autômato (${\displaystyle \mathbf{T}}$), e isso é difícil de fazer se o autômato não for determinístico (como é geralmente o caso de uma abstração). O fato de que a complementação de uma propriedade determinista é fácil, enquanto a complementação de uma propriedade não-determinística pode ser difícil, é um problema-chave com a contenção da linguagem. Isto levou a muita pesquisa em diferentes classes de $\omega$-autômatos com diferentes expressividade e dificuldade de complementação.

\section{Sistemas Dinâmicos Lineares}\label{sec:lds}

Sistemas dinâmicos lineares são sistemas dinâmicos~\cite{katok1995introduction} cujas funções de avaliação são lineares. Embora os sistemas dinâmicos em geral não tenham soluções de forma fechada, os sistemas dinâmicos lineares podem ser resolvidos com exatidão e possuem um rico conjunto de propriedades matemáticas. Sistemas lineares também podem ser usados para entender o comportamento qualitativo de sistemas dinâmicos gerais, calculando os pontos de equilíbrio do sistema e aproximando-o como um sistema linear em torno de cada um desses pontos.

Em um sistema dinâmico linear, a variação de um vetor de estado (um vetor ${\displaystyle N}$-dimensional dado por ${\displaystyle \mathbf{x}}$) é igual a uma matriz constante (dado por ${\displaystyle \mathbf{A}}$) multiplicada por ${\displaystyle \mathbf{x}}$. Essa variação pode ter duas formas: ou como um fluxo, no qual ${\displaystyle \mathbf{x}}$ varia continuamente com o tempo

\begin{equation}
\dot{{\displaystyle \mathbf{x}}}(t)={\displaystyle \mathbf{A}} \cdot {\displaystyle \mathbf{x}}(t)
\end{equation}

ou como um mapeamento, em que ${\displaystyle \mathbf{x}}$ varia em etapas discretas

\begin{equation}\label{eq:dtsx}
{\displaystyle \mathbf{x}}_{n+1}={\displaystyle \mathbf{A}} \cdot {\displaystyle \mathbf{x}}_n
\end{equation}

Estas equações são lineares no seguinte sentido: se ${\displaystyle \mathbf{x}(t)}$ e ${\displaystyle \mathbf{y}(t)}$ são duas soluções válidas, então também é qualquer combinação linear~\cite{rose1982linear} das duas soluções, por exemplo, ${\displaystyle \mathbf{z}(t) \ {\stackrel{\mathrm{def}} {=}} \ \alpha \mathbf{x}(t) + \beta \mathbf{y}(t)}$ onde ${\displaystyle \alpha}$ e ${\displaystyle \beta}$ são quaisquer dois escalares. A matriz ${\displaystyle \mathbf{A}}$ não precisa ser simétrica~\cite{weyl2015symmetry}.

Sistemas dinâmicos lineares podem ser resolvidos exatamente, em contraste com a maioria dos não-lineares. Ocasionalmente, um sistema não linear pode ser resolvido exatamente por uma mudança de variáveis para um sistema linear. Além disso, as soluções de (quase) qualquer sistema não linear podem ser bem aproximadas por um sistema linear equivalente próximo de seus pontos fixos~\cite{coxeter1998non}. Assim, entender os sistemas lineares e suas soluções é um primeiro passo crucial para entender os sistemas não-lineares mais complexos.

\subsection{Contínuos}\label{subsec:c}

Um sistema é chamado de sistema de tempo contínuo se aceitar sinais de tempo contínuo como entrada e gerar sinais de tempo contínuo como saída. A entrada será indicada por itálico em minúsculo $\mathit{u}(t)$ para entrada única ou por negrito $\mathbf{u}(t)$ para múltiplas entradas. Se o sistema tem $p$ entradas, então $\mathbf{u}(t)$ é um vetor $p \times 1$ ou $\mathbf{u} = [\mathit{u}_\mathrm{1} ~ \mathit{u}_\mathrm{2} ~ \dots ~ \mathit{u}_p]^T$, onde $T$ denota a transposição. Da mesma forma, a saída será denotada por $\mathit{y}(t)$ ou $\mathbf{y}(t)$. Supõe-se que o tempo $t$ varie de $-\infty$ a $\infty$.

\subsubsection{Equações de Espaço de Estados}\label{subsec:ssec}

Todo sistema agregado linear invariante no tempo pode ser descrito por

\begin{equation}\label{eq:ssec}
\begin{cases}
\dot{\mathbf{x}}(t)=\mathbf{A}\mathbf{x}(t)+\mathbf{B}\mathbf{u}(t)\\
\mathbf{y}(t)=\mathbf{C}\mathbf{x}(t)+\mathbf{D}\mathbf{u}(t)
\end{cases},
\end{equation}

\noindent Para um sistema com $p$ entradas, $q$ saídas e $n$ variáveis de estado, $A$, $B$, $C$ e $D$ são, respectivamente, $n \times n$, $n \times p$, $q \times n$ e $q \times p$ matrizes constantes. Aplicando a transformada de Laplace em~\ref{eq:ssec} e rearranjando, temos

\begin{equation}\label{eq:sc}
\hat{\mathbf{x}}(s)=~(s\mathbf{I}-\mathbf{A})^{-1}s\mathbf{x}(0)+(s\mathbf{I}-\mathbf{A})^{-1}\mathbf{B}\hat{\mathbf{u}}(s)
\end{equation}

\begin{equation}\label{eq:oc}
\hat{\mathbf{y}}(s)=~\mathbf{C}(s\mathbf{I}-\mathbf{A})^{-1}s\mathbf{x}(0)+\mathbf{C}(s\mathbf{I}-\mathbf{A})^{-1}\mathbf{B}\hat{\mathbf{u}}(s)+\mathbf{D}\hat{\mathbf{u}}(s)
\end{equation}

\noindent São equações algébricas. Dados $\mathbf{x}(0)$ e $\hat{\mathbf{u}}(s)$, $\hat{\mathbf{x}}(s)$ e $\hat{\mathbf{y}}(s)$ podem ser calculados algebricamente a partir de (\ref{eq:sc}) e (\ref{eq:oc}). Suas transformadas inversas de Laplace produzem as respostas de tempo $\mathbf{x}(t)$ e $\mathbf{y}(t)$. As equações também revelam o fato de que a resposta de um sistema linear pode ser decomposta como a resposta de estado zero e a resposta de entrada zero.

\subsection{Discretos}\label{subsec:d}

A maioria dos conceitos em sistemas de tempo contínuo pode ser aplicada diretamente aos sistemas de tempo discreto.
Um sistema é chamado de sistema de tempo discreto se aceitar sinais de tempo discreto como entrada e gerar sinais de tempo discreto como saída. Todos os sinais de tempo discreto em um sistema serão considerados como tendo o mesmo período de amostragem $T_\mathrm{s}$. A entrada e a saída serão denotadas por $u[k]:= u (kT)$ e $y[k]:= y(kT)$, onde $k$ denota o instante de tempo discreto e é um inteiro que varia de $-\infty$ a $\infty$. Eles se tornam negrito para múltiplas entradas e múltiplas saídas.

Um sistema de tempo discreto é causal se a saída atual depende de entradas atuais e passadas. O estado no tempo $k_\mathrm{0}$, denotado por $\mathbf{x}[k0]$, é a informação no instante de tempo $k_\mathrm{0}$, que junto com $\mathbf{u}[k]$, $k \geq k_\mathrm{0}$, determina unicamente a saída $\mathbf{y}[k]$, $k \geq k0$. As entradas de $\mathbf{x}$ são chamadas de variáveis de estado. Se o número de variáveis de estado for finito, o sistema de tempo discreto é agrupado; caso contrário, é distribuído. Todo sistema de tempo contínuo envolvendo atraso de tempo é um sistema distribuído. Em um sistema de tempo discreto, se o atraso de tempo for um múltiplo inteiro do período de amostragem $T_\mathrm{s}$, então o sistema de tempo discreto é um sistema aglomerado.

Um sistema de tempo discreto é linear se as propriedades de aditividade e homogeneidade se mantiverem. A resposta de cada sistema linear em tempo discreto pode ser decomposta como

\begin{equation*}
Resposta = resposta~ de ~estado~ zero~~ +~~ resposta ~de~ entrada~ zero
\end{equation*}

e as respostas de estado zero satisfazem a propriedade de superposição, e portanto as respostas de entrada zero também.

\subsubsection{Equações de Espaço de Estados}\label{subsec:sse}

Cada sistema de tempo discreto linear agregado e invariante no tempo pode ser descrito por

\begin{equation}\label{eq:ssed}
\begin{cases}
\mathbf{x}(k+1)=\mathbf{A}\mathbf{x}(k)+\mathbf{B}\mathbf{u}(k)\\
\mathbf{y}(k)=\mathbf{C}\mathbf{x}(k)+\mathbf{D}\mathbf{u}(k)\\
\mathbf{u}(k)=\mathbf{r}(k)-\mathbf{K}\mathbf{x}(k)
\end{cases},
\end{equation}

\noindent onde $\mathbf{A}$, $\mathbf{B}$, $\mathbf{C}$, $\mathbf{D}$ e $\mathbf{K}$ são matrizes contantes e $\mathbf{r}$ é a referência de entrada. Seja $\hat{\mathbf{x}}(z)$ a transformada ${\displaystyle Z}$  de $\mathbf{x}[k]$ ou

\begin{equation*}
\hat{\mathbf{x}}(z)=Z[\hat{\mathbf{x}}(k)]:=\sum_{k=0}^{\infty} \mathbf{x}(k)z^{-k}
\end{equation*}

\noindent Temos que

\begin{equation*}
\begin{aligned}
Z[\hat{\mathbf{x}}(k+1)]=&~\sum_{k=0}^{\infty} \mathbf{x}(k+1)z^{-k} \\
                        =&~z\left[\sum_{l=1}^{\infty} \mathbf{x}(l)z^{-l}+\mathbf{x}[0]-\mathbf{x}[0]\right]=z\left(\hat{\mathbf{x}}(z)-\mathbf{x}[0]\right)
\end{aligned}
\end{equation*}

\noindent Aplicando a transformada Z em~\ref{eq:ssed} e rearranjando, temos

\begin{equation*}
\begin{aligned}
\hat{\mathbf{x}}(z)=&~(z\mathbf{I}-\mathbf{A})^{-1}z\mathbf{x}[0]+(z\mathbf{I}-\mathbf{A})^{-1}\mathbf{B}\hat{\mathbf{u}}(z) \\
\hat{\mathbf{y}}(z)=&~\mathbf{C}(z\mathbf{I}-\mathbf{A})^{-1}z\mathbf{x}[0]+\mathbf{C}(z\mathbf{I}-\mathbf{A})^{-1}\mathbf{B}\hat{\mathbf{u}}(z)+\mathbf{D}\hat{\mathbf{u}}(z)
\end{aligned}
\end{equation*}

\subsection{Estabilidade de Sistemas Leneares Invariantes no Tempo}\label{subsec:ltis}

Os sistemas são projetados para executar algumas tarefas ou para processar sinais. Se um sistema não é estável, o sistema pode  ocasionar até mesmo desastres (queimar, desintegrar ou saturar quando um sinal, não importa quão pequeno seja, for aplicado). Portanto, um sistema instável é inútil na prática e a estabilidade é um requisito básico para todos os sistemas. Além da estabilidade, os sistemas devem atender a outros requisitos, como rastrear os sinais desejados e suprimir o ruído, para serem realmente úteis na prática. A resposta de sistemas lineares sempre pode ser decomposta como a resposta de estado zero e a resposta de entrada zero. É comum na literatura mostrar a estabilidade destas duas respostas separadamente. Nesta seção, faremos uma breve introdução de estabilidade BIBO (bounded-input bounded-output) para a resposta do estado zero e estabilidades marginais e assintóticas para a resposta da entrada zero, para o caso de sistemas em tempo discreto.

Dado o sistema em tempo discreto single-input single-output (SISO),

\begin{equation}\label{eq:bibo}
\mathbf{y}[k]=\sum_{m=0}^{k} g[k-m]\mathbf{m}[m]= \sum_{m=0}^{k} g[m]\mathbf{u}[k-m],
\end{equation}

\noindent onde $g[k]$ é a sequência de resposta ao impulso ou a seqüência de saída excitada por uma sequência de impulso aplicada em $k = 0$. Para ser descrito por (\ref{eq:bibo}), o sistema de tempo discreto deve ser linear, invariante no tempo, e causal. Além disso, o sistema deve ser inicialmente relaxado em $k = 0$.

Diz-se que uma sequência de entrada $\mathbf{u}[k]$ é limitada se $\mathbf{u}[k]$ não crescer até infinito positivo ou negativo ou se existir uma constante $\mathbf{u}[m]$ tal que $|\mathbf{u}[k]|\leq \mathbf{u}[m] < \infty$, para $k=0,1,2,\dots$.

Diz-se que um sistema é BIBO estável se toda sequência de entrada limitada excita uma sequência de saída limitada. Essa estabilidade é definida para a resposta do estado zero e é aplicável somente se o sistema estiver inicialmente relaxado.

O sistema em tempo discreto mostrado em (\ref{eq:dtsx}) é dito ser marginalmente estável ou estável no sentido de Lyapunov se todo estado inicial finito $\mathbf{x}_o$ excita uma resposta limitada. É assintoticamente estável se todo estado inicial finito excita uma resposta limitada, que, além disso, se aproxima de $0$ como $k \rightarrow \infty$.

Outra forma bastante comum de verificar a estabilidade de m sistema de tempo discreto é através da avaliação dos seus autovalores, ou seja, caso a magnitude dos autovalores da matrix de estado $\mathbf{A}$ for menor que $1$, o sistema [e dito estável. Se analisarmos o sistema resultante no domínio da frequência, os autovalores em malha fechada correspondem aos pólos da função de transferência em malha fechada.


\subsection{Processo de Discretização}\label{subsec:pd}

Segundo Smith \textit{et al.}~\cite{smith1997scientist}, a maioria dos sinais encontrados diretamente na ciência e na engenharia é contínuo: intensidade da luz que muda com a distância; tensão que varia ao longo do tempo; uma taxa de reação química que depende da temperatura, etc. A Conversão Analógico-Digital (CAD) e a Conversão Digital-para-Analógica (CDA) são os processos que permitem que os computadores digitais interajam com esses sinais cotidianos. A informação digital é diferente de sua contraparte contínua em dois aspectos importantes: é amostrada e quantizada. Ambos restringem a quantidade de informação que um sinal digital pode conter.

Considerando o sistema descrito na Equação~\ref{eq:ssec}, se o conjunto de equações é para ser computado em um computador digital, ele deve ser discretizado. Dado que $\dot{\mathbf{x}}(t)=\lim_{T_\mathrm{s}\to 0} \frac{\mathbf{x}(t+T_\mathrm{s})-\mathbf{x}(t)}{T_\mathrm{s}}$, pode-se aproximar Equação~\ref{eq:ssec}, usando $t=kT_\mathrm{s}$, para $k=0,1,\dots$, de

\begin{equation*}
\begin{cases}
\dot{\mathbf{x}}((k+1)T_\mathrm{s})=(\mathbf{I}+T_\mathrm{s}\mathbf{A})\mathbf{x}(kT_\mathrm{s})+T_\mathrm{s}\mathbf{B}\mathbf{u}(kT_\mathrm{s})\\
\mathbf{y}(kT_\mathrm{s})=\mathbf{C}\mathbf{x}(kT_\mathrm{s})+\mathbf{D}\mathbf{u}(kT_\mathrm{s})
\end{cases}
\end{equation*}

\noindent Esta é uma equação de espaço de estados em tempo discreto e pode ser facilmente computada em um computador digital. Esta discretização é a mais fácil de realizar, mas produz os resultados menos precisos para o mesmo $T_\mathrm{s}$. Discutimos a seguir uma discretização diferente.

Se uma entrada $\mathbf{u}(t)$ é gerada por um computador digital seguido por um conversor de digital para analógico, então $\mathbf{u}(t)$ será constante por partes. Essa situação geralmente surge no controle por computador dos sistemas de controle. Seja

\begin{equation}
\mathbf{u}(t) = \mathbf{u}(kT_\mathrm{s}) =: \mathbf{u}[k],~ para~ kT_\mathrm{s} \leq t < (k + 1)T_\mathrm{s}
\end{equation}

\noindent De acordo com Chen, podemos computar $\mathbf{x}[k+1]$, como

\begin{equation*}
\mathbf{x}[k+1]=e^{\mathbf{A}T_\mathrm{s}}\mathbf{x}[k]+\left( \int_{0}^{T_\mathrm{s}} e^{\mathbf{A}\alpha}d\alpha \right)\mathbf{B}\mathbf{u}[k]
\end{equation*}

Assim, se uma entrada altera o valor apenas em instantes de tempo discreto $kT$ e se computarmos apenas as respostas em $t = kT$, então (\ref{eq:ssec}) se tornam

\begin{equation}\label{eq:ssednova}
\begin{cases}
\mathbf{x}(k+1)=\mathbf{A}_d\mathbf{x}(k)+\mathbf{B}_d\mathbf{u}(k)\\
\mathbf{y}(k)=\mathbf{C}_d\mathbf{x}(k)+\mathbf{D}_d\mathbf{u}(k)\\
\end{cases},
\end{equation}

\noindent onde $\mathbf{A}_d=$, $\mathbf{B}_d=\int_{0}^{T_\mathrm{s}} e^{\mathbf{A}\tau}d\tau\mathbf{B}$, $\mathbf{C}_d=\mathbf{C}$ e $\mathbf{D}_d=\mathbf{D}$


Segundo Chen, a matriz $\mathbf{B}_d$ pode ser obtida por $\mathbf{B}_d=\mathbf{A}^{-1}(\mathbf{A}_d-\mathbf{I})\mathbf{B}$ (caso $\mathbf{A}$ não seja singular).

A solução das equações de estado para sistemas em tempo discreto pode ser obtida por

\begin{equation}\label{eq:solxd}
\mathbf{x}[k]=\mathbf{A}^k\mathbf{x}[0]+\sum_{m=0}^{k-1}(\mathbf{A}^{k-m-1}\mathbf{B}\mathbf{u}[m])
\end{equation}

\begin{equation}\label{eq:solyd}
\mathbf{y}(k)=\mathbf{C}\mathbf{A}^k\mathbf{x}[0]+\sum_{m=0}^{k-1}(\mathbf{C}\mathbf{A}^{k-m-1}\mathbf{B}\mathbf{u}[m])+\mathbf{D}\mathbf{u}[k]
\end{equation}

 

\subsection{Análise Quantitativa da Resposta ao Degrau}\label{subsec:aqrd}

Dado um sistema linear de entrada/saída (Eq.~\ref{eq:ssed}), a forma geral da solução da Equação~\ref{eq:ssed} é dada pela equação de convolução em (\ref{eq:solyd}). Vemos a partir da forma dessa equação que a solução consiste em uma resposta de condição inicial e uma resposta de entrada. A resposta de entrada, corresponde aos dois últimos termos da Equação \ref{eq:solyd}, consiste em dois componentes, a resposta transitória e a resposta em estado estacionário. A resposta transitória ocorre no primeiro período de tempo após a entrada ser aplicada e reflete a incompatibilidade entre a condição inicial e a solução de estado estacionário. A resposta de estado estacionário é a parte da resposta de saída que reflete o comportamento de longo prazo do sistema sob as entradas dadas. Para entradas que são periódicas, a resposta em estado estacionário será frequentemente periódica e, para entradas constantes, a resposta será frequentemente constante.

Uma forma de entrada particularmente comum é o degrau unitário, que representa uma mudança abrupta na entrada de um valor para outro.  Um degrau unitário (às vezes chamada de função de degrau Heaviside) é definida como

\begin{equation*}
  \mathbf{u}[k]=\systeme{
  0~  k<0,
  1~  k\geq 0
  }
\end{equation*}

Pode-se computar a resposta ao degrau de um sistema linear discreto através da Equação~\ref{eq:solyd}. Usando algumas operações algébricas, podemos chegar a conclusão de que a resposta em estado estacionário ao degrau unitário é dado por

\begin{equation}\label{eq:yss}
\begin{aligned}
y_{\mathrm{ss}}=\mathbf{C}(\mathbf{I}-\mathbf{A})^{-1}\mathbf{B}+\mathbf{D}.
\end{aligned}
\end{equation}

\noindent se $\mathbf{A}$ possui autovalores com valor módulo menor ou igual a $1$ (implicando que a origem é um ponto de equilíbrio estável na ausência de qualquer entrada).

A Figura~\ref{fig:output} ilustra a resposta ao degrau de um sistema discreto. Vários termos são usados ao se referir a uma resposta ao degrau. O valor do estado estacionário $y_{\mathrm{ss}}$ de uma resposta ao degrau é o nível final da saída, supondo que converge. O sobressinal $M_\mathrm{p}$ é a porcentagem do valor final pelo qual o sinal inicialmente se eleva acima do valor final. Isso geralmente pressupõe que os valores futuros do sinal não excedem o valor final em mais do que esse transitório inicial, caso contrário, o termo pode ser ambíguo. O tempo de assentamento $k_{\mathrm{s}}$ é o tempo necessário para o sinal ficar dentro de uma faixa de valores compreendidos $p\%$ acima e abaixo do valor final (neste trabalho tratado como região de assentamento $\Pi$) para todos os tempos futuros. O tempo de assentamento também é por vezes definido como atingindo $1\%$ ou $5\%$ do valor final. Em geral, essas medidas de desempenho podem depender da amplitude do degrau de entrada, mas, para sistemas lineares, as duas últimas quantidades definidas acima são independentes do tamanho do degrau. Por último, para este trabalho, definidos também o que chamados de tempo de alcance $k_{\mathrm{r}}$ que é a amostra onde a resposta do sistema alcança pela primeira vez a região de assentamento.

\begin{figure}[ht]
	\centering
	%\framebox{\parbox{4.6in}{
			\centering
			\includegraphics[trim={3.54cm 0cm 0cm 0cm}, clip, width=0.8\textwidth]{figures/output.eps}
			%}
	%}
	\caption{Step response of a discrete-time system.}
	\label{fig:output}
\end{figure}

\section{Técnicas de Projeto de Controle para Sistemas Discretos}\label{sec:tpcsd}

Quando projetamos controladores para sistemas em tempo discreto, dispomos de muitas tecnicas para realizar o projeto. Muita das vezes, precisa-se fazer uma análise minunciosa da técnica a ser emprega, devido ao teor do projeto em questão. A seguir, mostraremos algumas das técnicas utilizadas atualmente e que mais tarde será feito uma comparação das mesmas com a técnica que abordamos neste trabalho.

\subsection{Alocação de Polos}\label{subsec:ap}

Dado que o sistema em questão seja descrito como em (\ref{eq:ssed}), assumindo que tenha apenas um sinal de entrada, e o polinômio característico da matrix $\mathbf{A}$ seja $P(z)=z^n+p_\mathrm{1}z^{\mathrm{n-1}}+\dots + p_n$. 
Assumindo que o sistema em (\ref{eq:ssed}) é alcançável, pode-se transformá-lo na forma canônica, mudando as variáveis de estado pela transformação $z=T_\mathrm{s}\mathbf{x}$, e a equação de estado transformado é

\begin{equation}\label{eq:ssed2}
z(k+1)=\hat{\mathbf{A}}z(k)+\hat{\mathbf{B}}\mathbf{u}(k)
\end{equation}

Com o sistema sendo alcançável, existe uma realimentação linear que fornece um sistema em malha fechada com polinômio característico $P(z)$. A realimentação é dada por $\mathbf{u}[k]=-\mathrm{K}\mathbf{x}[k]$, com

\begin{equation}\label{eq:ctrlD}
\begin{aligned}
\mathbf{K}=&~(p_\mathrm{1}-a_\mathrm{1}~p_\mathrm{2}-a_\mathrm{2}~\dots~p_n-a_n)\hat{\mathbf{W}}_c \mathbf{W}_c^{-1} \\
          =&~(0~\dots~0~1)\mathbf{W}_c^{-1}P(\mathbf{A}) \\
\end{aligned},
\end{equation}

\noindent onde $\hat{\mathbf{W}}_c$ e $\mathbf{W}_c$ são as matrizes de alcançabilidade de (\ref{eq:ssed2}) e (\ref{eq:ssed}), respectivamente.

\begin{equation}\label{eq:reachM1}
\hat{\mathbf{W}}^{-1}_c=\begin{bmatrix}
1 & a_\mathrm{1} & \dots & a_{n-1} \\
0 & 1 & \dots & a_{n-2} \\
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & \dots & 1 
\end{bmatrix}
\end{equation}

\begin{equation}\label{eq:reachM2}
\mathbf{W}_c=(\mathbf{B}~\mathbf{A}\mathbf{B}\dots \mathbf{A}^{n-1}\mathbf{B})
\end{equation}




\subsection{Regulador Quadrático Linear}\label{subsec:rql}

O regulador quadrático linear LQR da teoria de controle ótimo pode ser usado para resolver uma família de problemas de projeto do regulador em que o estado é acessível e a regulação e o esforço do atuador são medidos por um desvio médio-quadrado. Uma formulação estocástica do problema LQR é conveniente para nós; uma formulação mais usual é como um problema de controle ótimo. O sistema é descrito por

\begin{equation*}
\dot{\mathbf{x}}=\mathbf{A}\mathbf{x}+\mathbf{B}\mathbf{u}+\mathbf{w},
\end{equation*}

\noindent onde $w$ é um ruído branco de média zero, isto é, $w$ tem matriz de densidade espectral de potência $S_\mathrm{w} (w) = I$ para todos $w$. O estado $\mathbf{x}$ está disponível para o controlador, então $\mathbf{y} = \mathbf{x}$ nesse \textit{framework}.

A função de custo do LQR é a soma do estado ponderado do quadrado médio do estado estacionário x, e o sinal do atuador ponderado do quadrado médio do estado estacionário u:

\begin{equation}
J_\mathrm{lqr} = \lim_{t\to \infty} \mathbf{E}(\mathbf{x}(t)^TQ\mathbf{x}(t)+\mathbf{u}(t)^TR\mathbf{u}(t)),
\end{equation}

\noindent onde Q e R são matrizes positivas de peso semidefinido; a
O primeiro termo penaliza os desvios de x de zero, e o segundo termo representa o custo de usar o sinal do atuador. Podemos expressar esse custo em nossa estrutura, formando o sinal de saída regulado $ \begin{bmatrix}
R^{\frac{1}{2}}u \\
Q^{\frac{1}{2}}x 
\end{bmatrix}  $, portanto, $J_\mathrm{lqr} = \lim_{t\to \infty} \mathbf{E}z(t)^Tz(t),$ o desvio quadrático médio de z. 

\subsection{Síntese Indutiva Guidada por Contra Exemplos - CEGIS}\label{subsec:cegis}

\section{Implementação de Controladores Digitais}\label{subsec:icd}

\subsection{Efeitos de Palavra Finita}\label{subsec:fwl}



SMT (\textit{Satisfiability Modulo Theories}) verifica a satisfatibilidade de fórmulas de primeira ordem a partir de uma ou mais teorias de fundamentação, que são compostas por um conjunto de sentenças. De modo formal, $\sigma$ -- \textit{theory} é uma coleção de sentenças sobre a assinatura $\sigma$. Dada uma teoria $T$, diz-se que $\varphi$ é um módulo satisfatível de $T$ se $T \subset {\phi}$. Em outra definição, pode-se dizer que uma teoria $T$ é definida como uma classe de estruturas e $\varphi$ é um módulo satisfatível se existe uma estrutura $M$ em $T$ que satisfaz $\varphi$ (\textit{i.e.}, $M \models \varphi$)~\cite{Moura:2009}.

Solucionadores SMT como o Z3~\cite{Moura:2008} e Boolector~\cite{Brummayer:2009} suportam diferentes tipos de teorias, de modo que o seu desempenho pode variar conforme a sua implementação.

\begin{table}[htb]
	\renewcommand{\arraystretch}{1.0}
	\caption{Exemplos de teorias suportadas.}
	\label{table:smt}
	\centering
	\begin{tabular}{c|c}
		\hline \bfseries Teoria & \bfseries Exemplo\\
		\hline Igualdade & $x_1 = x_2 \wedge \neg (x_2 = x_3) \Rightarrow \neg (x_1 = x_3)$\\
		\hline Aritmética Linear & $(7y_1 + y_2 \geq 5) \vee (y_2 + y_3 \leq 2)$\\
		\hline Vetores de $bit$ & $(b \gg i) \& 1 = 1$\\
		\hline Arranjos & $store(a, j, 5) \Rightarrow a[j] = 5$\\
		\hline Teorias Combinadas & $(j \leq k \wedge a[j] = 2) \Rightarrow a[i] < 3$\\
		\hline
	\end{tabular}
\end{table}

A Tabela~\ref{table:smt} mostra algumas das teorias suportadas pelos solucionadores SMT utilizados neste trabalho. A teoria de igualdade permite verificações de igualdade e desigualdade entre predicados utilizando os operadores ($=$) ($\leq$) ($<$). A teoria da aritmética linear é responsável apenas pelas funções aritméticas (adição, subtração, multiplicação e divisão) entre variáveis e constantes numéricas. A teoria de vetores de $bit$ permite operações $bit$ a $bit$ considerando diferentes arquiteturas (\textit{e.g.}, $32$ e $64$ $bits$), nela estão presentes os operadores: e ($\&$), ou ($\mid$), ou-exclusivo ($\bigoplus$), complemento ($\sim$), deslocamento para a direita ($\gg$) e deslocamento para a esquerda ($\ll$). Além disso, a teoria de arranjos permite a manipulação de operadores como $select$ e $store$.

Em contraste com as fórmulas geradas na satisfação booleana, que são apenas compostas por variáveis booleanas, as quais podem assumir valores verdadeiro e falso e conectivos lógicos, as fórmulas de primeira ordem são formadas por conectivos lógicos, variáveis, quantificadores, funções e símbolos de predicado~\cite{Moura:2009}. De modo geral, as teorias do módulo da satisfatibilidade tem sido aplicadas em diversos cenários~\cite{Moura:2018}, apresentando resultados mais promissores (se comparados à satisfação booleana), incluindo o suporte a diferentes teorias de decisão~\cite{Moura:2008, Moura:2009}.

\subsection{\textit{Efficient SMT-based Context-Bounded Model Checker}}\label{sec:esbmc}

O ESBMC é um verificador de modelos limitado ao contexto baseados nas teorias de módulo da satisfiabilidade (SMT), o qual é usado para verificar programas ANSI-C~\cite{Cordeiro:2012,DBLP:conf/tacas/MorseRCN014}. O ESBMC pode verificar tanto programas sequenciais quanto concorrentes e verifica propriedades relacionadas a estouro aritmético, divisão por zero, acesso ilegal a posições em memória, segurança de ponteiros, bloqueios fatais e corrida de dados. Esse processo é totalmente automático e não requer interação de usuário para anotar programas com pré- e/ou pós-condições.

No ESBMC, o programa a ser verificado é modelado como um sistema de transição de estados $M = (S, R, s_0)$, 
que é extraído de um gráfico de fluxo de controle (GFC). $S$ representa o conjunto de estados, $R \subseteq S \times S$ representa o conjunto de transições ({\it i.e.}, pares de estados que especificam como o sistema pode navegar de um estado para outro) e $s_0 \subseteq S$ representa o conjunto de estadaos iniciais. Um estado $s \in S$ consiste de um valor do contador de programa $pc$ e os valores de todas as variáveis do programa. Um estado inicial $s_0$ atribui a localização inicial do programa do GFC para o $pc$. Cada transição $\gamma = (s_i, s_{i+1}) \in R$ entre dois estados $s_i$ and $s_{i+1}$ é identificada como uma fórmula lógica $\gamma (s_i,s_{i+1})$ que captura as restrições nos valores do contador de programa e das variáveis do programa correspondentes.

Dado um sistema de transição $M$, uma propriedade de segurança $\phi$, um limite de contexto $C$ e um limite $k$, o ESBMC constrói uma árvore de alcançabilidade (AA) que representa o desdobramento do programa para $C$, $k$ e $\phi$. Ele então deriva uma condição de verificação (CV)$\psi^{\pi}_k$, para cada intercalação (ou caminho de computação) dada $\pi = \{v_1,...,v_k\}$, que é dada pela seguinte fórmula lógica:

\begin{equation}
\label{eq:bounded-model-checking}
    \psi^{\pi}_{k} =
    \overbrace{I(s_{0}) \wedge \bigvee_{i=0}^{k} \bigwedge_{j=0}^{i-1} \gamma(s_j,s_{j+1})}^{\textrm{restrições}}
    \wedge \overbrace{\neg \phi(s_i)}^{\textrm{propriedade}}
\end{equation}

Aqui, $I$ caracteriza o conjunto de estados iniciais $M$ e $\gamma(s_j,s_{j+1})$ é a relação de $M$ entre passos de tempo $j$ e $j+1$. Consequentemente, $I(s_0) \wedge \bigvee_{j=0}^{i-1} \gamma (s_j,s_{j+1})$ representa a executação de $M$ de largura $i$ e $\psi^{\pi}_{k}$ pode ser satisfatível se e somente se para algum $i \leq k$ existe um estado alcançável ao longo de $\pi$ em um passo de tempo $i$ no qual $\phi$ é violada. $\psi^{\pi}_{k}$ é uma fórmula livre de quantificadores em um subconjunto de lógica de primeira ordem decidível, o qual sua satisfiabilidade é verificada por um solucionador SMT. Se $\psi^{\pi}_{k}$ é satisfatível, então $\phi$ é violada ao longo de $\pi$ e o solucionador SMT fornece uma atribuição satisfatória, da qual pode-se extrair valores para variáveis do programa e construir um contraexemplo. Um contraexemplo para uma propriedade $\phi$ é uma sequência de estados $s_0,s_1,...,s_k$ com $s_0 \in S_0$, $s_k \in S$, e $\gamma (s_i, s_{i+1})$ para $0 \leq i < k$. Se $\psi^{\pi}_{k}$ não é satisfatível, pode-se concluir que nenhum estado de erro é alcançável em $k$ passos ou menos ao longo de $\pi$. Finalmente, pode-se definir $\psi_{k} = \bigwedge_{\pi} \psi_{k}^{\pi}$ e usá-la para verificar todos os caminhos.

No entanto, o ESBMC combina verificação de modelos simbólica com a exploração explícita do espaço de estados; em particular, ele explicitamente explora todas as possíveis intercalações (até o limite de contexto dado) enquanto ele trata cada intercalação em si simbolicamente. O ESBMC implementa diferentes variações dessa abordagem, que diferem no modo que elas são exploradas na AA. A variação mais eficaz simplesmente percore a AA em profundidade e chama o procedimento BMC sequencial para cada intercalação quando ela atinge um nodo folha da AA. Ele pára ou quando encontra erro ou sistematicamente explorou todas as possíveis intercalações da AA.

O modelo de memória do ESBMC usa análise estática de ponteiros, preenchimentos em estruturas, com o objetivo de alinhar todos os campos aos limites de palavra, forçamento de regras de alinhamento de acesso de memória e alocação de vetores de bytes, quando o tipo de alocação de memória não é claro, para que a fórmula SMT não seja tão extensa e suscetível a erros.

O ESBMC também implementa a prova por indução~\cite{MorseCNF13,Gadelha:2017} para verificar propriedades em programas, \textit{i.e.}, utilizar uma abordagem iterativa de aprofundamento para checar se uma propriedade de segurança $\phi$ é satisfeita em cada passo $k$. O ESBMC usa um algoritmo \textit{k-induction}, que consiste de três casos diferentes: caso base, condição adiante e passo indutivo. No caso base tenta-se encontrar um contraexemplo em até $k$ desdobramentos de laço; na condição adiante verifica-se se os laços foram completamente desdobrados e que $\phi$ é válida em todos os estados alcançáveis dentro de $k$ passos; no passo indutivo assegura-se que sempre que $\phi$ é válida para $k$ desdobramentos, ela também é válida após o próximo desdobramento do sistema.

Uma outra aplicação do ESBMC é a verificação de programas concorrentes para a plataforma CUDA~\cite{PereiraAMSCCSF16,Pereira:2016}. Utilizando um modelo operacional, \textit{i.e.}, uma representação abstrata das bibliotecas CUDA padrões que aproxima de forma conservadora as suas semânticas, o ESBMC é capaz de verificar propriedades de segurança em programas CUDA. Além disso, o ESBMC implementa a redução parcial de ordem e a análise de duas \textit{threads} para minimizar a exploração de espaço de estados.

\section{Localização de Falhas e Verificação de Modelos}\label{sec:fault-localization-and-model-checking}

\subsection{Uso de Contraexemplos para Localizar Falhas}\label{sec:using-counterexamples}

Em verificação de modelos, a atividade mais essencial, em relação à localização de falhas, é a de geração de um contraexemplo, o qual é produzido quando um programa não satisfaz uma dada especificação. Um contraexemplo não provê unicamente informações sobre a relação causa-efeito de uma dada violação, mas ele também pode auxiliar na localização de falhas, como Clarke {\it et al.}~\cite{Clarke:2003,Clarke:1995} citam. Mas, visto que uma grande massa de informação é obtida em um contraexemplo, as linhas de fato defeituosas não são facilmente identificadas.

Alguns métodos foram propostos, com o objetivo de localizar possíveis causas de falha, usando contraexemplos. Ball {\it et al.}~\cite{Ball:2003} propuseram uma abordagem que tenta isolar possíveis causas de contraexemplos, gerados pelo verificador de modelos SLAM~\cite{Ball:2001}. A ideia é que potenciais linhas defeituosas podem ser isoladas através de uma comparação entre as transições obtidas em contraexemplos e execuções bem-sucedidas, visto que transições não presentes em rastreamentos bem-sucedidos são potenciais causas de erros. Groce {\it et al.}~\cite{Groce:2003} afirmam que se um contraexemplo existe, um caminho similar mas não-defeituoso também existe e pode ser obtido usando técnicas de BMC. Elementos de programa relacionados a uma dada violação são sugeridos pelas diferenças entre tal contraexemplo e um caminho bem-sucedido. Tal abordagem é implementada no verificador de modelos {\it Java PathFinder}~\cite{JPF} e também pode porver caminhos de execução que levam a estados errôneos, com relação a programasa concorrentes ({\it e.g.}, corrida de dados). O conceito chave da abordagem descrita por Groce {\it et al.}~\cite{Groce:2006} é similar ao anterior e usa alinhamento de restrições para associar estados, em um contraexemplo, com os estados correspondentes em uma execução não-defeituosa, os quais são gerados por um solucionador de restrições. Os estados mencionados são estados abstratos sobre predicados, os quais representam estados concretos em uma execução. Usando propriedades de métricas de distância, restrições podem ser aplicadas para representar execuções do programa, e restrições sem correspondentes que representam estados concretos possivelmente levam a falhas. E ainda, se uma propriedade de métricas de distânica não é satisfeita, um contraexemplo é gerado pelo verificador de modelos~\cite{Groce:2006}.

\subsection{Localização de Falhas em Programas Sequenciais}\label{sec:sequential-fault-localization}

Griesmayer {\it et al.}~\cite{Griesmayer:2007} propuseram um método baseado em técnicas de BMC que pode diretamente identificar potenciais falhas em programas. Em particular, o método usa variáveis numéricas adicionais, {\it e.g.} \texttt{diag}, para apontar linhas defeituosas em um dado programa.

Cada linha do programa, representando uma declaração \texttt{S}, é transformada em uma versão lógica de tal declaração. Logo, o valor atribuído a \texttt{S} é ou não-deterministicamente escolhido pelo verificador de modelos (se o valor de \texttt{diag} for o mesmo que o representado pela linha relacionada à declaração \texttt{S}) ou o especificado originalmente. Os valores de \texttt{diag} obtidos pelo verificador de modelos representam linhas do programa e estão estritamente ligados à falha obtida, visto que, corrigindo essa linha no programa original, a falha em questão pode ser evitada. No caso de múltiplos valores de \texttt{diag}, corrigindo tais linhas levam a uma execução bem sucedida do programa. Com o intuito de encontrar o conjunto inteiro de linhas que causam o comportamento defeituoso no programa, uma nova especificação no comando de verificação\footnote{\texttt{assume(diag != a)}} pode ser adicionada ao código-fonte, o qual então é executado novamente pelo verificador de modelos. Esse processo é executado repetidamente até que não sejam obtidos novos valores para \texttt{diag}, {\it i.e.}, a execução não falha~\cite{Griesmayer:2007_2}.

Para ilustrar o funcionamento do método em questão, toma-se como exemplo um controlador digital baseado na fórmula da função horária do movimento retilíneo uniformemente variado (MRUV)~\cite{Ohanian:2006} (veja Equação~\ref{equation:space-equation}). A equação do controlador é definida na Equação~\ref{equation:controller-equation} (os valores foram atribuídos arbritariamente).

\begin{gather}
  s(t) = at^2/2+v_0t+s_0 \label{equation:space-equation}
\end{gather}

\begin{gather}
  c(t) = t^2-3t+2 \label{equation:controller-equation}
\end{gather}

Um modelo na linguagem C do controlador é modelado como na Figura~\ref{figure:sequential-code}.

\begin{figure}[ht]
\centering
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
#include <stdio.h>
#include <assert.h>

const int A = 1;
const int B = -2;
const int C = 2;

int controller(int input) {
  int output = A * input * input + B * input + C;
  return output;
}

int main() {
  assert(controller(0) == 2 && controller(1) == 0 && controller(2) == 0 && controller(3) == 2);
  return 0;
}
\end{lstlisting}
\end{minipage}
\caption{Código sequencial de um controlador qualquer.}
\label{figure:sequential-code}
\end{figure}

Pode-se observar que o modelo não está em conformidade com a equação dada, no caso o termo $B$ está com o valor $-2$ ao invés de $-3$. Dessa forma, espera-se que a assertiva falhe ao executar o programa em um verificador de modelos, como pode ser observado no trecho da Figura~\ref{figure:counterexample-model} (o contraexemplo completo está disponível no Apêndice~\ref{appendix:counterexample-1}).

\begin{figure}[ht]
\centering
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
...
Violated property:
  file model.c line 14 function main
  assertion 
  FALSE

VERIFICATION FAILED
\end{lstlisting}
\end{minipage}
\caption{Trecho do contraexemplo para o modelo.}
\label{figure:counterexample-model}
\end{figure}

Usando o ESMBC como verificador de modelos, o código instrumentado não-determinístico obtido é como na Figura~\ref{figure:griesmayer-method-applied-code}.

\begin{figure}[ht]
\centering
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
#include <stdio.h>
#include <assert.h>
const int A = 1;
const int B = -2;
const int C = 2;
int nondet(int i) {
  int ret;
  __ESBMC_assume(ret != i);
  return ret;
}
int controller(int input) {
  int diag = nondet(0);
  int ta = (diag == 1 ? nondet(A) : A) * input * input;
  int tb = (diag == 2 ? nondet(B) : B) * input;
  int tc = (diag == 3 ? nondet(C) : C);
  int output = ta + tb + tc;
  return output;
}
int main() {
  __ESBMC_assume(controller(0) == 2 && controller(1) == 0 && controller(2) == 0 && controller(3) == 2);
  assert(0);
  return 0;
}
\end{lstlisting}
\end{minipage}
\caption{Código sequencial instrumentado com o método descrito aplicado.}
\label{figure:griesmayer-method-applied-code}
\end{figure}

Ao executar o código da Figura~\ref{figure:griesmayer-method-applied-code} no ESBMC sucessivamente, \textit{i.e.}, até que não sejam encontrados novos valores para $diag$, obtém-se os valores presentes na Figura~\ref{figure:faulty-lines-griesmayer} (o contraexemplo completo está disponível no Apêndice~\ref{appendix:counterexample-2}).

\begin{figure}[ht]
\centering
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
griesmayer::controller::1::diag=-2012462479 (-2012462479)
griesmayer::controller::1::diag=2 (2)
griesmayer::controller::1::diag=2 (2)
griesmayer::controller::1::diag=2 (2)
\end{lstlisting}
\end{minipage}
\caption{Linhas defeituosas obtidas pela execução do código~\ref{figure:griesmayer-method-applied-code}.}
\label{figure:faulty-lines-griesmayer}
\end{figure}

Segundo o contraexemplo obtido com o ESBMC, pode-se observar que o valor de $diag$ é $2$ em três casos e um inteiro negativo em um caso. Logo, o problema está no cálculo do segundo termo, como esperado. O contraexemplo completo mostra que o valor para corrigir tal falha é $-3$. Assim, pode-se corrigir a falha apontada e reexecutar o código no verificador de modelos.

\begin{figure}[ht]
\centering
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
#include <stdio.h>
#include <assert.h>
const int A = 1;
const int B = -3;
const int C = 2;
int controller(int input) {
  int output = A * input * input + B * input + C;
  return output;
}
int main() {
  assert(controller(0) == 2 && controller(1) == 0 && controller(2) == 0 && controller(3) == 2);
  return 0;
}
\end{lstlisting}
\end{minipage}
\caption{Código sequencial corrigido.}
\label{figure:corrected-sequential-code}
\end{figure}

Após a correção do problema apontado, executa-se o código corrigido~\ref{figure:corrected-sequential-code} no ESBMC e obtém-se as linhas presentes na Figura~\ref{figure:correct-faulty-lines-griesmayer} (o contraexemplo completo está disponível no Apêndice~\ref{appendix:counterexample-3}). Em controladores digitais, é importante que os modelos sejam precisamente especificados para evitar falhas durante o funcionamento em ambiente real, visto que podem levar ao mal-funcionamento do equipamento e até danos, aumentando o custo do mesmo.

\begin{figure}[ht]
\centering
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}
griesmayer::controller::1::diag=-934770697 (-934770697)
griesmayer::controller::1::diag=-1 (-1)
griesmayer::controller::1::diag=-1 (-1)
griesmayer::controller::1::diag=-1 (-1)
\end{lstlisting}
\end{minipage}
\caption{Linhas defeituosas obtidas pela execução do código~\ref{figure:corrected-sequential-code}.}
\label{figure:correct-faulty-lines-griesmayer}
\end{figure}

Dessa forma, foi possível observar o método proposto por Griesmayer {\it et al.}~\cite{Griesmayer:2007} aplicado em um programa sequencial.

Este método foi escolhido para ser utilizado neste trabalho, pois além de ser simples a sua implementação, ele aponta não só linhas que contém defeitos, como também possíveis valores que levam a uma execução bem-sucedida do programa original.

\section{Resumo}\label{sec:chap-2-summary}

Neste capítulo, foram introduzidos os conceitos básicos para o entendimento desta dissertação, relacionadas à verificação de modelos. Mais especificamente, explicou-se o conceito de verificação de modelos limitada usando teorias de módulo da satisfiabilidade (SMT) com o verificador de modelos ESBMC ({\it Efficient SMT-based Context-Bounded Model Checker}), que verifica propriedades de programas sequenciais e concorrentes. Também foram mostradas discussões sobre o uso de contraexemplos para auxiliar no processo de localização de falhas. Por fim, foi apresentado um método para localizar falhas em programas sequenciais, usando não-determinismo para instrumentar atribuições, de forma que o verificador de modelos escolhe o valor para cada variável do programa para que propriedade (em forma de assertiva) presente no código seja satisfeita. Como resultado, o contéudo deste capítulo fornece todo o embasamento necessário para compreensão do trabalho desenvolvido, que será descrito nas seções subsequentes.
