\chapter{Trabalhos Relacionados}\label{chap_related_work}

Neste capítulo, serão descritos oito trabalhos relacionados que direta ou indiretamente abordam localização de falhas em programas concorrentes. Apesar de existirem outros estudos relacionados ao tema, foram selecionados apenas os que se assemelham a este trabalho.

Cada trabalho relacionado será descrito de acordo com suas características mais relevantes. Ao final de cada subseção serão destacados os melhores aspectos e os pontos fracos de cada um. Por fim, será feito um paralelo das características que são importantes para os objetivos propostos neste trabalho, que servirá como base de comparação.

\section{\textit{Formal Non-Fragile Stability Verification of Digital Control Systems with Uncertainty}}\label{sec:related-work-1}

Bessa {\it et al.}~\cite{bessa2017formal} apresentam uma metodologia de verificação para determinar formalmente a estabilidade incerta de sistemas lineares em controladores digitais com considerações sobre os aspectos de implementação. Especificamente, esta estratégia é combinada com o DSVerifier, que é uma ferramenta de verificação que utiliza a verificação de modelo limitado com base nas teorias de módulo de confiabilidade (SMT) para verificar a estabilidade dos sistemas de controle digital considerando incerteza. O DSVerifier determina a estabilidade do sistema de controle, considerando a planta, juntamente com os efeitos do comprimento da palavra finita (FWL) na implementação do controlador digital. Em seguinda, verifica-se a estabilidade robusta ``não frágil'' de um determinado sistema em malha fechada. A metodologia proposta e a respectiva ferramenta (DSVerifier) são avaliadas considerando exemplos de controle não frágeis encontrados na literatura.

O trabalho mostra que a técnica é capaz de prever problemas de fragilidade em controladores robustos quando consideramos a estabilidades de sistemas de controle digital, visto que leva em consideração os efeito FWL. No entanto, este trabalho se prende a apenas verificar a estabilidade, sendo que aspectos de desempenho são deixados de lado, visto que as propriedades de desempenho são super importantes quando se projeta controladores, além de já considerarem a estabilidade.

\section{\textit{Formal Analysis of Robustness at Model and Code Level }}\label{sec:related-work-2}

Wang {\it et al.}~\cite{WangGRJF16} apresentam uma abordagem de verificação da robustez de sistemas de controle, a nivel de código e modelagem, onde se baseia em um cálculo invariante na dinâmica discreta do sistema. Usando solucionadores de programação semi-definida (SDP), uma função baseada em Lyapunov é sintetizada, capturando as margens do vetor do sistema linear em malha fechada considerado. Essa invariante numérica expressa sobre as variáveis de estado do sistema é compatível com a análise de código e permite sua validação no artefato de código. Esta análise automática amplia as técnicas de verificação focadas na implementação do controlador, abordando a validação da robustez no modelo e no nível de código. Ele foi implementado em uma ferramenta que analisa sistemas SISO discretos e gera super-aproximações de margens de fase e ganho.

Os autores apresentam uma abordagem eficaz para verificar robustez dos controladores digitais a nivel de código e modelagem. Novamente, esse trabalho emprega a verificação usando uma abordagem a nivel de código, porém não considera aspectos de desempenho do controlador, apesar de considerar aspectos relativos a efeitos causados pela aritmética de ponto fixo.

\section{\textit{Temporal Logic Control of Discrete-Time Piecewise Affine Systems}}\label{sec:related-work-3}

Yordanov {\it et al.}~\cite{yordanov2012temporal} apresentam uma estrutura computacional para síntese automática de uma estratégia de controle de realimentação para um sistema de tempo discreto (mais precisamente sistemas PWA) a partir de uma especificação dada como uma lógica linear temporal (LTL) sobre um conjunto arbitrário de predicados lineares nas variáveis de estado do sistema. A abordagem consiste em definir partições apropriadas para seu estado e espaços de entrada, e então constrói-se uma abstração finita do sistema na forma de um sistema de transição de controle. Depois disso, aproveitando ideias e técnicas de verificação de modelos LTL e jogos de Rabin, desenvelvoram um algoritmo para gerar uma estratégia de controle para a abstração finita.

A abordagem apresentada para a construção da abstração garante que uma estratégia de controle gerada para o sistema de controle finito pode ser facilmente transformada em uma estratégia de controle para o sistema PWA inicial. Embora comprovadamente correta, a solução geral é conservadora e computacionalmente cara. Apesar de esta abordagem conseguir sintetizar controladores, deixa de considerar alguns aspectos bem relevantes em projetos de controladores digitais, como aspectos de desempenho e efeitos da fragilidade de controladores quando implementados em microprocessadores.

\section{\textit{Formal Methods for Adaptive Control of Dynamical Systems}}\label{sec:related-work-4}

Sadraddini and Belta~\cite{sadraddini2017formal} desenvolveram um método para controlar sistemas de tempo discreto com parâmetros constantes mas inicialmente desconhecidos a partir de especificações de lógica temporal linear (LTL).Os autores usam as noções de sistemas de transição paramétricos e adaptativos (não-determinísticos) e ferramentas de métodos formais para computar estratégias de controle adaptativo para sistemas finitos. 

Apesar de não utilizar os métodos tradicionais de controle adaptativo, usando uma abordagem correta por construção a qual não requer um modelo de referência e pode lidar com uma gama muito maior de sistemas e especificações, não leva em consideração aspectos relativos a depensempenho de sistemas considerando a resposta ao degrau, bem como deixa de lado aspectos enfrentados com a implementação, como os efeitos de FWL. Como a maioria das outras aplicações de métodos formais, os resultados sofrem pela alta complexidade computacional. Como discutido no artigo, o número de estados no sistema de transição adaptativa (ATS) pode ser muito grande. Além disso, a construção de quocientes finitos para sistemas infinitos é computacionalmente difícil.

\section{\textit{Correct-by-construction Adaptive Cruise Control: Two Approaches}}\label{sec:related-work-5}

Nilsosn {\it et al.}~\cite{nilsson2016correct} descrevem duas abordagens para sintetizar controladores correto por construção em sistemas de controle de cruzeiro adaptativo. Ambas as abordagens baseiam-se na computação em pontos fixos no domínio do controlador, a partir da qual a especificação em lógica linear temporal (LTL) pode ser aplicada. Uma calcula tais pontos fixos diretamente no espaço de estados contínuo, a outra em uma abstração de estados finitos da dinâmica não-linear.

De acordo com os resultados experimentais, este trabalho se mostra eficaz para sistemas de controle de cruzeiro adaptativo. Porém, leva em consideração a síntese de controladores estáveis considerando a propriedade de \textit{safety}, mas n'ao aborda questões de projeto de controladores referentes a desempenho a resposta ao degrau.

\section{\textit{Formal Specification and Analysis Approaches for Spacecraft Attitude Control Requirements}}\label{sec:related-work-6}

Gross {\it et al.}~\cite{gross2017formal} propuseram uma abordagem para formalizar requisitos comuns de sistema de controle de atitude de naves espaciais, como limites do atuador, erro de indicação, alcançabilidade, desvio, tempo de assentamento, tempo de subida e sobressinal. Os autores utlizaram métodos formais, mais especificamente verificação de modelos e teste de hipótese para verificar requisitos de desempenho de sistemas de controle de atitude de naves espaciais. O trabalho em questão avalia esses sistemas e verifica se obedecem a esses requisitos no domínio do tempo contínuo. Embora a intenção inicial de formalizar os requisitos fosse conduzir análises formais de métodos para determinar se o projeto de controle de atitude de naves espaciais atendia aos requisitos do sistema, as equações de movimentos não-lineares se mostraram muito complexas para os solucionadores e apenas alguns requisitos puderam ser analisados.

Um ponto positivo desse trabalho foi que consideraram aspectos de desempenho na verificação de controladores. Apesar disso, os autores não trabalharam com sistemas em tempo discreto, não levando em consideração aspectos de implementação, como os efeitos FWL.

\section{\textit{Robust Controller Synthesis of Switched Systems Using Counterexample Guided Framework}}\label{sec:related-work-7}

Ravanbakhsh and Sankaranarayanan~\cite{ravanbakhsh2016robust} investigam o problema de sintetizar controladores robustos que asseguram que o sistema em malha fechada satisfaça uma especificação de \textit{reach-while-stay} de entrada, em que todas as trajetórias partindo de um conjunto inicial $I$, eventualmente atingem um conjunto de metas especificadas $G$, enquanto permanecem dentro de um conjunto seguro $S$. A ideia chave é: dado o modelo da planta que consiste em um sistema comutado de tempo contínuo controlado por um sinal de comutação externo e entradas de perturbação da planta, o controlador usa uma lei de realimentação de estado para controlar o sinal de comutação, a fim de garantir que as propriedades de correção desejadas sejam mantidas, independentemente das ações de perturbação. Para garantir a especificação de \textit{reach-while-stay}, a abordagem usa um certificado de prova na forma de uma função robusta de controle Lyapunov (\textit{robust control Lyapunov-like function} - RCLF). Para encontrar um RCLF, usa-se uma estrutura de síntese indutiva guiada por contra-exemplo (CEGIS), resolvendo iterativamente uma fórmula $\exists \forall \exists \forall$ usando solucionadores SMT livres de quantificação. Finalmente, utilizaram o problema de traduzir o RCLF sintetizado pela abordagem em uma implementação de controle.

A técnica de síntese de controladores para sistemas de controle comutados apresentada aparesentou bons resultados pelo que se propos a fazer, considerando sistemas de controle em tempo contínuo. Porém, deixou de considerar aspectos de implementação desses controladores do mundo real, onde necessita-se trabalhar com sistemas em tempo discreto, e levar em conta aspectos de implementação, como efeitos de FWL. O problema de sintetizar controladores para satisfazer requisitos da propriedade \textit{reach-while-stay} tem sua importância, mas outros aspectos como estabilidade e requisitos de desempenham devem ser considerados em projeto de controladores para problemas do mundo real.

\section{\textit{Multi-objective design of state feedback controllers using reinforced quantum-behaved particle swarm optimization}}\label{sec:related-work-8}

Hassani and Lee~\cite{hassani2016multi} apresentam um paradigma de projeto genérico multi-objetivo que utiliza otimização de enxame de particulas (\textit{particle swarm optimization} - PSO) com comportamento quântico (QPSO) para decidir a configuração ideal do controlador LQR para um determinado problema, considerando um conjunto de objetivos concorrentes. Existem três contribuições principais introduzidas nesse trabalho da seguinte forma: o algoritmo QPSO padrão é reforçado com um esquema de inicialização informado baseado no algoritmo de recozimento simulado e no mecanismo de seleção de vizinhança gaussiana, ele também é aumentado com uma estratégia de busca local que integra as vantagens do algoritmo memético no QPSO convencional, e também é introduzido um critério agregado de ponderação dinâmica que combina dinamicamente as restrições \textit{soft} e \textit{hard} com os objetivos de controle para fornecer ao projetista um conjunto de soluções ótimas de Pareto e permite que ela decida a solução de destino com base nas preferências práticas.

O trabalho em questão se mostra bastante promissor, visto que faz uma certa análise a aspectos de desempenho de sistemas de controle. Apesar disso, a análise toda é feita considerando controladores em tempo contínuo. Apenas é feito uma ``melhoria`` nos parâmetros de desempenho do sistemas, mas não sintetiza controladores com base nesses parâmetros como requisitos necessários e específicos. Como não trabalha diretamente com sistemas de controle digital, consequentemente não leva em conta aspectos de implementação dos mesmo em microprocessadores, podendo gerar controladores que quando implementados nessas plataformas não se comporte conforme projetado, visto que podem sofrer com os efeitos de FWL, por exemplo.


\section{\textit{Formal Synthesis of Analytic Controllers for Sampled-Data Systems via Genetic Programming}}\label{sec:related-work-9}

Verdier {\it et al.}~\cite{verdier2018formal} apresentam um método automático de síntese de controladores para sistemas de amostragem de dados não-lineares com especificações de segurança e alcançabilidade. Basicamente, a estratégia apresentada não se limita aos sistemas polinomiais e controladores. Considera-se ocasionalmente controladores comutados baseados em funções de barreira de controle Lyapunov. A estratégia proposta utiliza programação genética para sintetizar essas funções, bem como os modos do controlador. A exatidão do controlador é verificada por meio de um solucionador de hipótese de módulo de satisfiabilidade.

De acordo com o estudo apresentado, a metodologia utlizada apresentou bons resultados, considerando o que os autores se propuseram a fazer. Apesar disso, testaram apenas em sistemas até terceira ordem. Além do mais, trabalharam apenas com sistemas contínuos considerando somente estabilidade do sistemas e desconsiderando aspectos de implementação em sistemas microprocessados, como os efeitos de FWL.


\section{\textit{Automated Formal Synthesis of Digital Controllers for State-Space Physical Plants}}\label{sec:related-work-10}

Abate {\it et al.}~\cite{abate2017automated} propõem uma abordagem sólida e automatizada para sintetizar controladores digitais com realimentação seguros para plantas físicas representadas como modelos lineares invariantes no tempo. Os autores utilizaram síntese indutiva guiada por contra-exemplo (CEGIS) o qual possui duas fases: síntese de um controlador de realimentação estático que estabiliza o sistema, mas que pode não ser seguro para todas as condições iniciais. A segurança é então verificada via verificação de modelos limitada (\textit{bounded model checking} - BMC) ou aceleração abstrata; se a etapa de verificação falhar, um contra-exemplo é fornecido ao mecanismo de síntese e o processo itera até que um controlador seguro seja obtido.

O trabalho em questão apresenta excelentes resultados, porém ainda deixa de considerar aspectos de desempenho de projeto de controladores, considerando somente a estabilidade dos mesmos. Um bom aspecto é que a metodologia considera fragilidade na implementação dos controladores digitais.


\section{Comparação entre os Trabalhos}

Os trabalhos relacionados tratam de verificação de sistemas de controle que é uma das fases deste trabalho, e síntese de controladores de sistemas de controle. Pode-se notar a respeito dos trabalhos analisados que o problema de síntese de controladores digitais é pertinente, visto que este processo é bastante necessário na fase de projeto de um controlador digital. A síntese de controladores digitais para sistemas de controle foi observado como um problema complexo e de difícil uma grande abrangênciade problemas devido a muitos trabalhos abordarem o problema de diferentes maneiras e levando em consideração fatores diferentes. Sabendo disso, as principais diferenças entre a abordagem proposta nesse trabalho para as aqui discutidas podem ser listadas: trabalha com sistemas de controle em tempo discreto o qual é o que efetivamente é usado quando implementamos utilizando uma plataforma microprocesada; a metodologia proposta sintetiza e verifica controladores considerando requisitos de desempenho de sistemas de controle; e, finalmente, consideramos aspectos de implementação que podemn ocasionar mal funcionamento dos sistemas de controle, visto que os efeitos de FWL, por exemplo, podem levar a isso. A Tabela~\ref{table:related-work-comparison} mostra um quadro comparativo entre a metodologia proposto nesta dissertação e os trabalhos relacionados selecionados.

\begin{table}[ht]
    \renewcommand{\arraystretch}{1.0}
    \caption{Comparação dos trabalhos relacionados}
    \label{table:related-work-comparison}
    \centering
    \begin{tabular}{c|c|c|c|c}
        \hline \shortstack{\bfseries Trabalhos} & \bfseries Suporte a & \bfseries Suporte a & \bfseries Considera os & \bfseries Síntese e\\
\bfseries relacionados & \bfseries sistemas & \bfseries requisitos de & \bfseries efeitos & \bfseries de casos\\
\bfseries & \bfseries discretos & \bfseries desempenho & \bfseries de FWL & \bfseries Verificação\\
        \hline Bessa {\it et al.} (2017) & X & & X & \\
        \hline Wang {\it et al.} (2016) & X & & & \\
        \hline Yordanov {\it et al.} (2012) & X & & & \\
        \hline Sadraddini and Belta (2017) & X & & & \\
        \hline Nilsosn {\it et al.} (2016) & X & & X & \\
        \hline Gross {\it et al.} (2017) & & X & & \\
        \hline Ravanbakhsh and Sankaranarayanan (2016) & & & & X\\
        \hline Hassani and Lee (2016) & & X & & \\
        \hline Verdier {\it et al.} (2018) & & & & \\
        \hline Abate {\it et al.} (2017) & X & & X & X\\
        \hline Metodologia proposta & X & X & X & X\\
	\end{tabular}
\end{table}

Através da Tabela~\ref{table:related-work-comparison} pode-se observar que existem outros trabalhos que são capazes de localizar falhas em programas concorrentes. No entanto, nenhum deles é capaz de atingir ambos objetivos em programas escritos na linguagem C e, ainda mais, sem o auxílio de casos de teste previamente escritos, diferentemente do método proposto.

\section{Resumo}\label{chap-3-summary}

Neste capítulo foram apresentados diversos trabalhos relacionados a algum dos seguintes problemas: localização de falhas, suporte a programas concorrentes, verificação de código escrito na linguagem C e/ou dependência de casos de testes externos. Após a apresentação de cada técnica, assim como uma breve discussão sobre as vantagens e desvantagens de cada uma delas, foi feita uma comparação com o método proposto neste trabalho. Foi possível observar que o método proposto aborda os três primeiros itens sem a necessidade de casos de testes externos, o que o diferencia dos demais trabalhos. O próximo capítulo apresenta a metodologia proposta para localizar falhas em programas concorrentes utilizando técnicas de sequencialização e BMC.