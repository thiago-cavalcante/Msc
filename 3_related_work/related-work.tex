\chapter{Trabalhos Relacionados}\label{chap_related_work}

Neste capítulo, serão descritos oito trabalhos relacionados que direta ou indiretamente abordam localização de falhas em programas concorrentes. Apesar de existirem outros estudos relacionados ao tema, foram selecionados apenas os que se assemelham a este trabalho.

Cada trabalho relacionado será descrito de acordo com suas características mais relevantes. Ao final de cada subseção serão destacados os melhores aspectos e os pontos fracos de cada um. Por fim, será feito um paralelo das características que são importantes para os objetivos propostos neste trabalho, que servirá como base de comparação.

\section{\textit{Formal Non-Fragile Stability Verification of Digital Control Systems with Uncertainty}}\label{sec:related-work-1}

Bessa {\it et al.}~\cite{bessa2017formal} apresentam uma metodologia de verificação para determinar formalmente a estabilidade incerta de sistemas lineares em controladores digitais com considerações sobre os aspectos de implementação. Especificamente, esta estratégia é combinada com o DSVerifier, que é uma ferramenta de verificação que utiliza a verificação de modelo limitado com base nas teorias de módulo de confiabilidade (SMT) para verificar a estabilidade dos sistemas de controle digital considerando incerteza. O DSVerifier determina a estabilidade do sistema de controle, considerando a planta, juntamente com os efeitos do comprimento da palavra finita (FWL) na implementação do controlador digital. Em seguinda, verifica-se a estabilidade robusta ``não frágil'' de um determinado sistema em malha fechada. A metodologia proposta e a respectiva ferramenta (DSVerifier) são avaliadas considerando exemplos de controle não frágeis encontrados na literatura.

O trabalho mostra que a técnica é capaz de prever problemas de fragilidade em controladores robustos quando consideramos a estabilidades de sistemas de controle digital, visto que leva em consideração os efeito FWL. No entanto, este trabalho se prende a apenas verificar a estabilidade, sendo que aspectos de desempenho são deixados de lado, visto que as propriedades de desempenho são super importantes quando se projeta controladores, além de já considerarem a estabilidade.

\section{\textit{Formal Analysis of Robustness at Model and Code Level }}\label{sec:related-work-2}

Wang {\it et al.}~\cite{WangGRJF16} apresentam uma abordagem de verificação da robustez de sistemas de controle, a nivel de código e modelagem, onde se baseia em um cálculo invariante na dinâmica discreta do sistema. Usando solucionadores de programação semi-definida (SDP), uma função baseada em Lyapunov é sintetizada, capturando as margens do vetor do sistema linear em malha fechada considerado. Essa invariante numérica expressa sobre as variáveis de estado do sistema é compatível com a análise de código e permite sua validação no artefato de código. Esta análise automática amplia as técnicas de verificação focadas na implementação do controlador, abordando a validação da robustez no modelo e no nível de código. Ele foi implementado em uma ferramenta que analisa sistemas SISO discretos e gera super-aproximações de margens de fase e ganho.

Os autores apresentam uma abordagem eficaz para verificar robustez dos controladores digitais a nivel de código e modelagem. Novamente, esse trabalho emprega a verificação usando uma abordagem a nivel de código, porém não considera aspectos de desempenho do controlador, apesar de considerar aspectos relativos a efeitos causados pela aritmética de ponto fixo.

\section{\textit{Temporal Logic Control of Discrete-Time Piecewise Affine Systems}}\label{sec:related-work-3}

Yordanov {\it et al.}~\cite{yordanov2012temporal} apresentam uma estrutura computacional para síntese automática de uma estratégia de controle de realimentação para um sistema de tempo discreto (mais precisamente sistemas PWA) a partir de uma especificação dada como uma lógica linear temporal (LTL) sobre um conjunto arbitrário de predicados lineares nas variáveis de estado do sistema. A abordagem consiste em definir partições apropriadas para seu estado e espaços de entrada, e então constrói-se uma abstração finita do sistema na forma de um sistema de transição de controle. Depois disso, aproveitando ideias e técnicas de verificação de modelos LTL e jogos de Rabin, desenvelvoram um algoritmo para gerar uma estratégia de controle para a abstração finita.

A abordagem apresentada para a construção da abstração garante que uma estratégia de controle gerada para o sistema de controle finito pode ser facilmente transformada em uma estratégia de controle para o sistema PWA inicial. Embora comprovadamente correta, a solução geral é conservadora e computacionalmente cara. Apesar de esta abordagem conseguir sintetizar controladores, deixa de considerar alguns aspectos bem relevantes em projetos de controladores digitais, como aspectos de desempenho e efeitos da fragilidade de controladores quando implementados em microprocessadores.

\section{\textit{Formal Methods for Adaptive Control of Dynamical Systems}}\label{sec:related-work-4}

Sadraddini and Belta~\cite{sadraddini2017formal} desenvolveram um método para controlar sistemas de tempo discreto com parâmetros constantes mas inicialmente desconhecidos a partir de especificações de lógica temporal linear (LTL).Os autores usam as noções de sistemas de transição paramétricos e adaptativos (não-determinísticos) e ferramentas de métodos formais para computar estratégias de controle adaptativo para sistemas finitos. 

Apesar de não utilizar os métodos tradicionais de controle adaptativo, usando uma abordagem correta por construção a qual não requer um modelo de referência e pode lidar com uma gama muito maior de sistemas e especificações, não leva em consideração aspectos relativos a depensempenho de sistemas considerando a resposta ao degrau, bem como deixa de lado aspectos enfrentados com a implementação, como os efeitos de fwl. Como a maioria das outras aplicações de métodos formais, os resultados sofrem pela alta complexidade computacional. Como discutido no artigo, o número de estados no sistema de transição adaptativa (ATS) pode ser muito grande. Além disso, a construção de quocientes finitos para sistemas infinitos é computacionalmente difícil.

\section{\textit{Correct-by-construction Adaptive Cruise Control: Two Approaches}}\label{sec:related-work-5}

Nilsosn {\it et al.}~\cite{nilsson2016correct} descrevem duas abordagens para sintetizar controladores correto por construção em istemas de controle de cruzeiro adaptativo. Ambas as abordagens baseiam-se na computação em pontos fixos no domínio do controlador, a partir da qual a especi?cação em lógica linear temporal (LTL) pode ser aplicada. Uma calcula tais pontos fixos diretamente no espaço de estados contínuo, a outra em uma abstração de estados finitos da dinâmica não-linear.

De acordo com os resultados experimentais, este trabalho se mostra eficaz para sistemas de controle de cruzeiro adaptativo. Porém, leva em consideração a síntese de controladores estáveis considerando a propriedade de \textit{safety}, mas n'ao aborda questões de projeto de controladores referentes a desempenho a resposta ao degrau.

\section{\textit{Formal Specification and Analysis Approaches for Spacecraft Attitude Control Requirements}}\label{sec:related-work-6}

Gross {\it et al.}~\cite{gross2017formal} propuseram uma abordagem para formalizar requisitos comuns de sistema de controle de atitude de naves espaciais, como limites do atuador, erro de indicação, alcançabilidade, desvio, tempo de assentamento, tempo de subida e sobressinal. Os autores utlizaram métodos formais, mais especificamente verificação de modelos e teste de hipótese para verificar requisitos de desempenho de sistemas de controle de atitude de naves espaciais. O trabalho em questão avalia esses sistemas e verifica se obedecem a esses requisitos no domínio do tempo contínuo. Embora a intenção inicial de formalizar os requisitos fosse conduzir análises formais de métodos para determinar se o projeto de controle de atitude de naves espaciais atendia aos requisitos do sistema, as equações de movimentos não-lineares se mostraram muito complexas para os solucionadores e apenas alguns requisitos puderam ser analisados.

Um ponto positivo desse trabalho foi que consideraram aspectos de desempenho na verificação de controladores. Apesar disso, os autores não trabalharam com sistemas em tempo discreto, não levando em consideração aspectos de implementação, como os efeitos fwl.

\section{\textit{Formal Synthesis of Analytic Controllers for Sampled-Data Systems via Genetic Programming.}}\label{sec:related-work-7}

Park {\it et al.}~\cite{Park:2014} apresentam um método de localização de falhas dinâmico para localizar as raízes da causa de defeitos de concorrência e a implementação de um protótipo da técnica, chamado \textsc{Falcon}. Usando detecção dinâmica de padrões e localização de falhas estatística, o \textsc{Falcon} é capaz de mostrar a existência de defeitos em programas concorrentes, tanto de atomicidade quanto violação de ordem, auxiliando desenvolvedores a corrigir falhas em códigos. A técnica utiliza dados providos por casos de teste para o programa em verificação e tenta encontrar padrões pré-estabelecidos de acesso à memória compartilhada. Tais padrões são organizados estatisticamente de forma a priorizar quais as possíveis falhas existentes no programa.

De acordo com o estudo empírico realizado pelos autores, a técnica aparentou ser eficaz para tratar violações de atomicidade e ordem em programa concorrentes, mostrando-se eficiente em termos de espaço e tempo utilizado. No entanto, essa abordagem foi desenvolvida apenas para lidar com programas Java, depende de casos de teste para a procura por padrões defeituosos e, no trabalho em questão, os autores apenas avaliaram a ferramenta com uma entrada de teste e múltiplas execuções do programa.

\section{\textit{Cause Clue Clauses: Error Localization using Maximum Satisfiability}}\label{sec:related-work-8}

Jose {\it et al.}~\cite{Jose:2011} discutem sobre um algoritmo para localização de causas de erro, considerando uma redução para o {\it problema da satisfiabilidade máxima} (MAX-SAT), que aponta o número máximo de cláusulas de uma fórmula booleana que uma atribuição pode satisfazer simultaneamente. A ideia chave é combinar uma fórmula de rastreamento booleana e uma fórmula não-satisfatível, ambas em relação ao desdobramento do programa e uma execução do programa malsucedida, e usar MAX-SAT para encontrar o conjunto máximo de cláusulas que podem ser satisfeitas ao mesmo tempo nessa fórmula. O complemento desse conjunto devolvido pelo solucionador MAX-SAT contém os locais do programa que levam ao erro, logo, corrigindo esses locais, é possível conseguir uma execução sem falhas do programa para o caso de teste dado. Vale ressaltar que o uso de MAX-SAT também foi abordado por Trindade {\it et al.}~\cite{Trindade:2016} no ESBMC para avaliar o problema de particionamento de hardware-software.

O algoritmo apresentado é capaz de localizar linhas defeituosas e os autores também realizaram experimentos para sugerir reparos de atribuições aritméticas e troca de operadores de comparação no código original. Apesar dessa abordagem ser útil para localizar linhas defeituosas, ela ainda depende de uma execução malsucedida, e funciona apenas para para programas ANSI-C padrão.

\section{\textit{Automated Formal Synthesis of Digital Controllers for State-Space Physical Plants}}

Hong {\it et al.}~\cite{abate2017automated} propõem uma abordagem sólida e automatizada para sintetizar controladores digitais com realimentação seguros para plantas físicas representadas como modelos lineares invariantes no tempo. Os autores utilizaram síntese indutiva guiada por contra-exemplo (CEGIS) o qual possui duas fases: síntese de um controlador de realimentação estático que estabiliza o sistema, mas que pode não ser seguro para todas as condições iniciais. A segurança é então verificada via verificação de modelos limitada (BMC, do inglês \textit{bounded model checking}) ou aceleração abstrata; se a etapa de verificação falhar, um contra-exemplo é fornecido ao mecanismo de síntese e o processo itera até que um controlador seguro seja obtido.

O trabalho em questão apresenta excelentes resultados, porém ainda deixa de considerar aspectos desempenho de projeto de controladores, considerando somente a estabilidade dos mesmos. Um bom aspecto é que a metodologia considera fragilidade na implementação dos controladores digitais.

\section{\textit{Metallaxis-FL: Mutation-Based Fault Localization}}

Papadakis {\it et al.}~\cite{Papadakis:2015} apresentam uma abordagem de localização de falhas baseadas em análise de mutação, chamada \textit{Metallaxis}. A abordagem consiste em usar mutantes e associá-los com potenciais locais defeituosos do programa, e quando mutantes são mortos (principalment por casos de testes que falham), tais são essencialmente bons indicadores sobre os locais defeituosos de um programa.  Ainda mais, a abordagem apresentada usa em seu favor um número alto de casos de teste para ordenar instruções mutadas, com relação à sua pontuação de suspeita, o qual leva a falhas no programa. De acordo com dados experimentais, \textit{Metallaxis} é substancialmente mais efetivo que abordagens baseadas em instruções, até quando técnicas de redução de custo de mutação (\textit{e.g.}, amostragem de mutação) são usada. \textit{Metallaxis} localiza falhas efetivamente e, visto que ele funciona sobre uma suíte de teste, ele só pode ser usado durante o teste para localizar potenciais falhas.

A abordagem se mostra superior a abordagens baseadas em instruções; no entanto, ela ainda deende de uma extensa suíte de teste e só foi avaliada em software ANSI-C procedural/sequencial.

\section{Comparação entre os Trabalhos}

Os trabalhos relacionados tratam ou de localização de falhas em programas ou em verificação de programas concorrentes. Foi possível observar que o problema de localização de falhas é pertinente, visto que este processo toma muito tempo dos desenvolvedores no ciclo de desenvolvimento de software. O tratamento de programas concorrentes também foi observado como um problema complexo de ser tratado devido ao grande número de possibilidades nas tentativas de simular um comportamento defeituoso. Tendo esses pontos em mente, as principais diferenças entre a abordagem proposta nesse trabalho para as aqui discutidas podem ser listadas: o método proposto requer apenas o código-fonte do programa, em contraste com outros métodos, onde mais dados são necessários, como uma execução malsucedida; o método proposto funciona para programas concorrentes em C, amplamente usados em sistemas embarcados; e, finalmente, é possível apontar linhas defeituosas facilmente, enquanto que outras abordagens verificam a segurança de um programa. A Tabela~\ref{table:related-work-comparison} mostra um quadro comparativo entre o método proposto nesta dissertação e os trabalhos relacionados selecionados.

\begin{table}[ht]
    \renewcommand{\arraystretch}{1.0}
    \caption{Comparação dos trabalhos relacionados}
    \label{table:related-work-comparison}
    \centering
    \begin{tabular}{c|c|c|c|c}
        \hline \shortstack{\bfseries Trabalhos} & \bfseries Localiza & \bfseries Aplicável em & \bfseries Verifica & \bfseries Necessita\\
\bfseries relacionados & \bfseries falhas & \bfseries programas & \bfseries código & \bfseries de casos\\
\bfseries & & \bfseries concorrentes & \bfseries C & \bfseries de teste\\
        \hline Jones {\it et al.} (2009) & X & & X & X\\
        \hline Cleve {\it et al.} (2005) & X & & X & X\\
        \hline Birch {\it et al.} (2015) & X & & X & X\\
        \hline Tomasco {\it et al.} (2015) & & X & X &\\
        \hline Cordeiro {\it et al.} (2011) & & X & X &\\
        \hline Griesmayer {\it et al.} (2007) & X & & X &\\
        \hline Park {\it et al.} (2014) & X & X & &\\
        \hline Jose {\it et al.} (2011) & X & & X &\\
        \hline Hong {\it et al.} (2015) & X & & X & X\\
        \hline Papadakis {\it et al.} (2015) & X & & X & X\\
        \hline Método proposto & X & X & X &\\
	\end{tabular}
\end{table}

Através da Tabela~\ref{table:related-work-comparison} pode-se observar que existem outros trabalhos que são capazes de localizar falhas em programas concorrentes. No entanto, nenhum deles é capaz de atingir ambos objetivos em programas escritos na linguagem C e, ainda mais, sem o auxílio de casos de teste previamente escritos, diferentemente do método proposto.

\section{Resumo}\label{chap-3-summary}

Neste capítulo foram apresentados diversos trabalhos relacionados a algum dos seguintes problemas: localização de falhas, suporte a programas concorrentes, verificação de código escrito na linguagem C e/ou dependência de casos de testes externos. Após a apresentação de cada técnica, assim como uma breve discussão sobre as vantagens e desvantagens de cada uma delas, foi feita uma comparação com o método proposto neste trabalho. Foi possível observar que o método proposto aborda os três primeiros itens sem a necessidade de casos de testes externos, o que o diferencia dos demais trabalhos. O próximo capítulo apresenta a metodologia proposta para localizar falhas em programas concorrentes utilizando técnicas de sequencialização e BMC.