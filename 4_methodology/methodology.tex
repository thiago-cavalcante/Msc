\chapter{A Metodologia Proposta}\label{chap_methodology}

Neste capítulo, a metodologia proposta para sintetizar controlodores digitais com realimentação de estados, considerando fragilidade e especificações de desempenho será completamente descrita. Primeiramente, mostraremos as metodologias formalizadas para verificar sistemas de controle digital, com respeito a especificações de performance, no caso máximo tempo de assentamento e máximo sobressinal. A formalização utilizada para estimar o máximo sobressinal, bem como a invariante formalizada para verificar o máximo tempo de assentamento. Também são descritos os algoritmos criados para fazer a devida verificação das mesmas. Finalmente, a descrição completa da técnica que utilizamos para realizar o processo de síntese.

%\section{Visão Geral do Método}
%\label{sec:method-overview}
%
%Aqui, o método proposto é descrito brevemente, como mostrado na Figura~\ref{figure:methodology}, e uma explicação mais detalhada é exposta nas seções seguitnes. Dado um programa concorrente $P$, primeiramente checa-se se ele apresenta uma execução mal-sucedida com relação a uma determinada intercalação. Para realizar tal tarefa, $P$ é executado em um verificador de modelos duas vezes: a primeira execução verifica se existe algum bloqueio fatal e a segunda é responsável por outros tipos de violação, tais como erros de aquisição de semáforo, divisão por zero, segurança de ponteiros, estouro aritmético e violação de limites de vetores. Não é possível verificá-lo apenas uma vez porque os verificadores de modelos separam essas verificações, \textit{i.e.}, é necessário adicionar uma opção de linha de comando para habilitar a detecção de bloqueios fatais e ignorar violações devido a assertivas. Caso um contraexemplo possa ser obtido nesse passo, é possível prosseguir com o método. Então, o próximo passo define as regras de transformação, que são as instruções sequenciais que substituirão as originais concorrentes, e um arcabouço sequencial, o qual tem como objetivo simular a execução concorrente da intercalação mal-sucedida. O terceiro passo consiste em usar o método proposto por Griesmayer~\cite{Griesmayer:2007} para instrumentar atribuições e expressões, de forma a apontar locais e instruções defeituosas do programa. Tal programa instrumentado pode então ser executado, usando um verificador de modelos, e é possível coletar as linhas defeituosas, até que a verificação associada não produza diferentes elementos. Essa iteração é descrita na Figura~\ref{figure:methodology} por meio dos passos $3$, $4$, já que o método busca novos contraexemplos, com o intuito de encontrar novas linhas defeituosas. Finalmente, as linhas defeituosas são obtidas, assim como atribuições necessárias para produzir uma execução bem-sucedida de $P$.
%
%\begin{figure}[ht]
%  \centering
%  \includegraphics[scale=0.35]{figures/methodology}
%  \caption{Metodologia proposta.}
%  \label{figure:methodology}
%\end{figure}

%-------------------------------------------------------------------
\section{Verificação de Requisitos de Especificação de Desempenho Não-frágil}
\label{sec:verification}
%-------------------------------------------------------------------

Neste trabalho utilizamos uma variação da síntese de CEGIS para sintetizar um controlador digital, a fim de satisfazer os requisitos de máximo sobressinal e de máximo tempo de assentamento. Na estratégia do CEGIS, temos basicamente duas etapas principais: síntese e verificação. Nesta seção, mostramos o método de verificação do tempo de assentamento e do máximo sobressinal dos sistemas de controle digital.
%--------------------------------------------------------------------------------
\subsection{Estimativa do Máximo Sobressinal}
\label{sec:modformver}
%--------------------------------------------------------------------------------

Algoritmo~\ref{alg:overshootEst} descreve um procedimento para estimar $y_{\mathrm{p}}$ (valor máximo de pico na resposta de um sistema) e $k_{\mathrm{p}}$ (amostra onde $y_{\mathrm{p}}$ está localizado), a fim de encontrar uma abordagem formal para verificar o máximo sobressinal usado em nossa abordagem de CEGIS.

\begin{algorithm}[H]
\footnotesize
  \renewcommand{\algorithmcfname}{Algoritmo}%
  \SetAlgoLined
  %\KwPr{}
  $y_\mathrm{p} \gets y(k)$\;
  $lastGrad \gets 1$\;
  \While{verdadeiro}{
  \eIf{$|y(k+1)|>|y(k)|$}{
     $gradient = (gradient>0)?(gradient+1):1$\;
     \If{$|y(k+1)| != |y(k)|$}{
      $firstGradSample = y(k+1)$\;
      $firstGradSampleIdx = k+1$\;
    }
  }{
    $gradient = (gradient<0)?(gradient-1):-1$\;
  }
  \If{$(lastGrad>0) ~and~ (gradient < 0)$}{
     \uIf{$|firstGradSample| <= |k_\mathrm{p}|$}{
       increment $numBadPeaks$\;
       \eIf{$numBadPeaks > 2$}{
         termina\;
       }{
         $y_\mathrm{p} = firstGradSample$\;
         $k_\mathrm{p} = firstGradSampleIdx$\;
       }
     }\uElseIf{$(grad > 10) ~and~ (|(y(k+1)-yss)/yss| < 0.001)$}{
       \eIf{$|yss|>|y_\mathrm{p}|$}{
         $y_\mathrm{p} = yss$\;
         $k_\mathrm{p} = 0$\;
       }{
         termina\;
       }
     }
  }
  $lastGrad = grad$\;
  incrementar $k$\;
  }
  \caption{\texttt{estimate\_maxPeak\_value} - Estimation of $y_{\mathrm{p}}$ and $k_{\mathrm{p}}$}\label{alg:overshootEst}
\end{algorithm}

O procedimento basicamente procura o valor de pico máximo na resposta da saída de um sistema, usando o conceito de gradiente para verificar se há um pico. Começamos na primeira amostra do sistema de saída e comparamos as amostras subsequentes, e então continuamos a encontrar o maior pico (com o mesmo sinal de $y_\mathrm{ss}$) que é o nosso valor máximo de pico $y_\mathrm{p}$.


%--------------------------------------------------------------------------------
\subsection{Estimação da Invariante de Máximo Tempo de Assentamento}
\label{sec:modformver}
%--------------------------------------------------------------------------------

Nesta etapa deste trabalho, desejamos verificar se um determinado sistema de controle digital atende a um tempo de assentamento requerido e, como consequência, precisamos modelar seu comportamento. Além disso, usamos $\hat{k}$ como uma invariante para a verificação de tempo de assentamento. Um mapeamento $\phi$ de uma dada coleção $M$ de objetos matemáticos dotados de uma relação de equivalência fixa $\rho$, em outra coleção $N$ de objetos matemáticos, que é constante nas classes de equivalência de $M$, com relação a $\rho$ (mais precisamente, isso é uma invariante da relação de equivalência $\rho$ em $M$). Se $X$ é um objeto em $M$, então pode-se dizer que $\phi(M)$ é uma invariante do objeto $X$~\cite{springer2006invariant}. Em outras palavras, uma vez que calculamos $\hat{k}$, ele permanecerá inalterado.

Nesse sentido, dado que $S_\mathrm{1}=\{|\lambda_{\mathrm{1}},|\lambda_{\mathrm{2}},\dots,|\lambda_n|\}$ seja o conjunto de valores absolutos de autovalores~\cite{chen1995linear} do sistema $\Omega$ e $\overline{\lambda} = \max(S_{\mathrm{1}})$. Podemos agora definir uma função heurística que representa a resposta de saída de $\bar{\Omega}$ como

\begin{equation}\label{eq:saidaNova}
\overline{y}(k)=y_{\mathrm{ss}}+\overline{c}\overline{\lambda}^{k}~,
\end{equation}

\noindent onde $\overline{c}$ é uma constante que faz $\overline{y}(k)$ entrar na região de assentamento $\Pi$. Na verdade, a função heurística acima usa o autovalor mais ``lento'' $\bar{\lambda}$, garantindo que $\bar{\Omega}$ sempre alcance a região assentamento após $\Omega$.

Em resumo, podemos encontrar uma função heurística baseada no maior autovalor de $\Omega$, em termos de magnitude, e então verificar o momento em que ela entra em uma região assentamento porque se isso acontecer antes do tempo de assentamento requerido, isso também é válido para $\Omega$.

Para verificar o tempo de assentamento de um sistema, indicamos uma região de assentamento como uma porcentagem $ p $, geralmente entre $ 0 \% $ e $ 5 \% $~\cite{dorf2011modern}, portanto seus limites superior e inferior são,

\begin{equation}\label{eq:lupp}
L_{\mathrm{upp}}=\left(1+\frac{p}{100}\right) y_{\mathrm{ss}}
\end{equation}

\noindent e
\begin{equation}
L_{\mathrm{low}}=\left(1-\frac{p}{100}\right) y_{\mathrm{ss}},
\end{equation}

\noindent respectivamente. O instante ($\hat{k}$) quando um sistema entra em sua região de assentamento pode ser encontrado simplesmente fazendo com que Eq.~\eqref{eq:saidaNova} seja igual a Eq.~\eqref{eq:lupp}, devido à forma da curva na Eq.~\eqref{eq:saidaNova}, como segue:

\begin{center}
\begin{equation*}
\begin{aligned}
\left( 1+\frac{p}{100}\right) y_{\mathrm{ss}}=y_{\mathrm{ss}}+\overline{c}\overline{\lambda}^{\hat{k}}\\
y_{\mathrm{ss}}+\frac{p}{100}y_{\mathrm{ss}}=y_{\mathrm{ss}}+\overline{c}\overline{\lambda}^{\hat{k}} \\
\overline{c}\overline{\lambda}^{\hat{k}}=\frac{p}{100}y_{\mathrm{ss}} \\
\log_{\overline{\lambda}} \overline{\lambda}^{\hat{k}}=\log_{\overline{\lambda}}\left( \frac{p}{100\overline{c}}y_{\mathrm{ss}}\right)
\end{aligned}
\end{equation*}

\begin{equation}\label{eq:kbar}
\begin{aligned}
{\hat{k}}=\ceil{  \log_{\overline{\lambda}}\left( \frac{p}{100\overline{c}}y_{\mathrm{ss}}\right)}.
\end{aligned}
\end{equation}
\end{center}

O maior pico da saída do sistema, $y_\mathrm{p}$, pode ser obtido para calcular $\overline{c}$ e, como consequência, com Eq.~\eqref{eq:saidaNova}, fazemos

\begin{equation}\label{eq:cbar}
\begin{aligned}
y_{\mathrm{p}}=&~y_{\mathrm{ss}}+\bar{c}{\bar{\lambda}}^{k_{\mathrm{p}}} \\
\bar{c}=&~\frac{y_{\mathrm{p}}-y_{\mathrm{ss}}}{{\bar{\lambda}}^{k_{\mathrm{p}}}}.
\end{aligned}
\end{equation}

\noindent $y_\mathrm{p}$ pode ser obtido, verificando a saída do sistema para encontrar o maior valor em magnitude com o mesmo sinal de $y_\mathrm{ss}$ e $k_\mathrm{p}$ é a amostra em que $y_\mathrm{p}$ está localizado.

\subsection{Algoritmo de Verificação de Sobressinal}
\label{subsec:overshootAlg}

Nesta seção, explicamos nossa técnica de verificação de máximo sobressinal, que consiste em verificar se o percentual exigido de sobressinal é menor ou igual ao percentual de sobressinal real (calculado).

O máximo sobressinal ($M_{\mathrm{p}}$) é o valor máximo transitório que excede $y_{\mathrm{ss}}$. A fim de encontrar a porcentagem de sobressinal, nós executamos a seguinte computação:

\begin{equation}
\begin{aligned}
M_{\mathrm{p}} =&~ y_{\mathrm{p}}-y_{\mathrm{ss}} \\
PO =&~ 100\times\frac{M_{\mathrm{p}}}{y_{\mathrm{ss}}},
\end{aligned}
\label{eq:perc_overshoot}
\end{equation}
\noindent  onde $y_{\mathrm{p}}$ pode ser obtido do Algoritmo~\ref{alg:overshootEst}.

A Figura~\ref{fig:overshootDiag} mostra a metodologia de verificação de sobressinal proposta, que foi implementada no DSVerifier. Em primeiro lugar, o modelo de um sistema de controle (\texttt{Step 1}) é determinado e, em seguida, um controlador é projetado em malha fechada (\texttt{Step 2}). Depois disso, a implementação de FWL (\texttt{Step 3}) e o máximo sobressinal requerido para ser verificado (\texttt{Step 4}) são definidos, os quais são então usados para criar o arquivo \texttt{SpecsFile.ss}. Em seguida, a estabilidade do sistema é verificada e, se for estável, a especificação do máximo sobressinal é avaliada.
  
\begin{figure}[H]
\begin{center}
\includegraphics[trim={0.0cm 0.0cm 0.0cm 0cm}, clip,width=0.8\textwidth]{figures/ArchOverShooting.eps}
\caption{Verificação de Sobressinal.} 
\label{fig:overshootDiag}
\end{center}
\end{figure}

A verificação de máximo sobressinal consiste basicamente em verificar se a porcentagem de sobressinall computada $P.O.$ (Eq.~\ref{eq:perc_overshoot}) é menor do que o percentual de sobressinal requerido ($P.O._{\mathrm{r}}$). Se for esse o caso, ele retorna \texttt{Verification SUCCESSFUL}; caso contrário, \texttt{Verification FAILED} será exibido, conforme ilustrado no Algorithm~\ref{alg:overshootReal}.

%\begin{algorithm}[H]
%\caption{Verify Overshoot }
%\label{alg:overshootReal}
%\begin{algorithmic}[1]
%\Procedure{checkOvershoot($y_{\mathrm{ss}}$, $PO_{\mathrm{r}}$)}{}
%
%    \State $y_{\mathrm{p}} \gets estimate\_maxPeak\_value() $
%    \State $PO \gets \frac{y_{\mathrm{p}}-y_{\mathrm{ss}}}{y_{\mathrm{ss}}}$
%
%    \If {$PO > PO_{\mathrm{r}}$}
%  
%      \State \textbf{return} Verification Failed
%        
%    \EndIf
%
%\State \textbf{return} Verification Successful
%
%\EndProcedure
%\end{algorithmic}
%\end{algorithm}

\begin{algorithm}[H]
  \renewcommand{\algorithmcfname}{Algoritmo}%
  \SetAlgoLined
%  \KwPr{}
  \KwData{$y_{\mathrm{ss}}$, $PO_{\mathrm{r}}$}
%  \KwRes{how to write algorithm with \LaTeX2e }
  $y_{\mathrm{p}} \gets estimate\_maxPeak\_value() $\;
  $PO \gets \frac{y_{\mathrm{p}}-y_{\mathrm{ss}}}{y_{\mathrm{ss}}}$\;
  \eSe{$PO > PO_{\mathrm{r}}$}{
     Verification Failed\;
  }{
  Verification Successful\;
  }
  \caption{Verify Overshoot}\label{alg:overshootReal}
\end{algorithm}


\subsection{Algoritmo de Verificação de Tempo de Assentamento}
\label{subsec:settime-alg}

Nesta seção, mostramos nosso algoritmo para verificação de tempo de assentamento, onde usamos o invariante $\hat{k}$ (veja a seção \ref{sec:modformver}). Nossa metodologia, que é ilustrada na Figura\ref{fig:diag1}, fornece verificação de tempo de assentamento em sistemas em malha aberta e fechada; no entanto, os primeiros não apresentam controladores e, consequentemente, os efeitos de FWL não são levados em conta. A primeira etapa consiste em obter os parâmetros de entrada necessários, matrizes de espaço de estados $ A $, $ B $, $ C $ e $ D $ e uma entrada do sistema $ u $, que é seguida por um controlador digital, se um sistema em malha fechada for considerado (\texttt{Step 2}). Então, o tempo de assentamento requerido $t_{\mathrm{sr}}$, a porcentagem $ p $ da região de assentamento e o tempo de amostragem $T_\mathrm{s}$ são definidos (\texttt{Step 4 }), que é seguido por uma implementação de FWL, quando em malha fechada (\texttt{Step 3}). Depois disso, os passos \texttt{A} a \texttt{E} são executados, {\it i.e.}, cálculo do controlador com FWL, se for escolhido em malha fechada (\texttt{Step A}) e valor de estado estacionário ($y_{\mathrm{ss}}$), como descrito em Eq.~\eqref{eq:yss} (\texttt{Step B}), estimativa dos maiores valores de pico da saída do sistema ($y_{\mathrm{p}}$) e a amostra $k_{\mathrm{p}}$ onde $y_{\mathrm{p}} $ está localizado (\texttt{Step C}) e, finalmente, computação de $\overline{\lambda}$ (\texttt{Step D}), $\overline{c}$ e $\hat{k}$ (\texttt{Step E}).

%\begin{algorithm}
%    \caption{Procedure to find the instant $k_\mathrm{r}$}
%    \label{alg:kreach}
%    \begin{algorithmic}[1] % The number tells where the line numbering should start
%        \Procedure{}{}
%          \While {$y(k) \not\subset \Pi$}
%            \State increment $k$
%          \EndWhile
%          \State $k_\mathrm{r} \gets k$
%        \EndProcedure
%    \end{algorithmic}
%\end{algorithm}

\begin{algorithm}[H]
  \renewcommand{\algorithmcfname}{Algoritmo}%
  \SetAlgoLined
  \Eq{$y(k) \not\subset \Pi$}{
    incrementar $k$\;
  }
  $k_\mathrm{r} \gets k$\;
  \caption{Procedimento para encontrar o instante $k_\mathrm{r}$}\label{alg:kreach}
\end{algorithm}


\begin{figure*}[ht]
\begin{center}
\includegraphics[trim={0.0cm 0.0cm 0.0cm 0cm}, clip,width=0.8\textwidth]{figures/Archstever.eps}
\caption{Metodologia de Verificação de Tempo de Assentamento.} 
\label{fig:diag1}
\end{center}
\end{figure*}

O procedimento proposto para verificar os tempos de assentamento, que é descrito no Algoritmo~\ref{alg:settlingtime}, consiste em primeiro verificar se $\hat{k}$, que foi previamente calculado e usado como parâmetro, é menor que tempo de assentamento requerido $k_{\mathrm{sr}} = \ceil{\frac{t_{\mathrm{sr}}} {T_\mathrm{s}}}$, que também pode ser verificado através de $\hat{k} \times T_{\mathrm{s}} \leq t_{\mathrm{sr}}$ (como usado no Algorithm~\ref{alg:settlingtime}). Se este for o caso, podemos assegurar que o sinal de saída está dentro de $\Pi$ (veja Seção \ref{sec:modformver}) após $t_{\mathrm{sr}}$ e, como consequência, a verificação associada já é bem sucedido; caso contrário, ainda precisamos verificar se $y$ permanece dentro de $\Pi$ de $k_{\mathrm{sr}}$ a $\hat{k}$ e, se este último não for verdadeiro para qualquer amostra $y$, a verificação resultante falha.


%\begin{algorithm}[H]
%\caption{Verify Settling Time }
%\label{alg:settlingtime}
%\begin{algorithmic}[1]
%\Procedure{checkSettlingTime(%$\hat{k}$, $t_{\mathrm{sr}}$, $T_{\mathrm{s}}$, $L_{\mathrm{low}}$, $L_{\mathrm{upp}}$
%)}{}
%
%  \If {$y_\mathrm{p} \subset \Pi$}
%    \State {$\hat{k} \gets k_\mathrm{r}$}
%  %\EndIf
%  
%  \Else
%
%    \State $k \gets \frac{t_{\mathrm{sr}}}{T_{\mathrm{s}}}$
%    \If {$k > \hat{k}$}
%      \State \textbf{return} Verification Successful
%    \Else
%      \While{$k \leq \hat{k}$}
%
%      \If {$y(k) < L_{\mathrm{low}}\ or \ y(k) > L_{\mathrm{upp}}$}
%  
%        \State \textbf{return} Verification Failed
%        
%      \EndIf
%  
%    \State increment $k$
%  
%    \EndWhile
%    \State \textbf{return} Verification Successful
%    \EndIf
%  \EndIf
%  
%  \If {$t_{\mathrm{sr}}<\hat{k} \times T_{\mathrm{s}}$}
%    \State \textbf{return} Verification Failed
%    \Else
%    \State \textbf{return} Verification Successful
%  \EndIf
%\EndProcedure
%\end{algorithmic}
%\end{algorithm}

\begin{algorithm}[H]
  \renewcommand{\algorithmcfname}{Algoritmo}%
  \SetAlgoLined
  \eSe{$y_\mathrm{p} \subset \Pi$}{
     $\hat{k} \gets k_\mathrm{r}$\;
  }{
  $k \gets \frac{t_{\mathrm{sr}}}{T_{\mathrm{s}}}$\;
  \eSe{$k > \hat{k}$}{
     $\hat{k} \gets k_\mathrm{r}$\;
  }{
  \Eq{$k \leq \hat{k}$}{
    \Se{$y(k) < L_{\mathrm{low}}\ or \ y(k) > L_{\mathrm{upp}}$}{
      Verification Failed\;
    }
    increment $k$\;
  }
  }
  }
  \eSe{$t_{\mathrm{sr}}<\hat{k} \times T_{\mathrm{s}}$}{
     Verification Failed\;
  }{
    Verification Successful\;
  }
  \caption{Verify Settling Time}\label{alg:settlingtime}
\end{algorithm}


\subsection{Exemplo de Verificação}
\label{subsec:under_examp}

A fim de fornecer uma compreensão mais profunda sobre os algoritmos de verificação de máximo sobressinal e tempo de assentamento, a seguir é apresentado um exemplo prático. Começando com a metodologia proposta para a verificação de máximo sobressinal, temos que definir um sistema e depois analisá-lo, de acordo com a nossa abordagem:


\begin{equation}
\label{eq:discsystemcomplete3}
\Omega:\begin{cases}
x(k+1)=\begin{bmatrix}
1.5 & 1.0 & 0.0 \\
0.0 & 1.5 & 1.0 \\
0.0 & 0.0 & 1.5 
\end{bmatrix}x(k)+\begin{bmatrix}
-0.4 \\
2.5 \\
-0.8 
\end{bmatrix}u(k)\\
y(k)=\begin{bmatrix}
0.0 & 2.6 & 0.0 
\end{bmatrix}x(k)+[0]u(k)\\
u(k)=r(k)-Kx(k)
\end{cases},
\end{equation}
%
\noindent onde $r(k)=u_{\mathrm{-1}}$ é o degrau unitário.

Desta forma, \texttt{Step 1} está pronto e \texttt{Step 2} é então considerado, onde uma matriz do controlador $\mathbf{K}$ não está definida, devido à operação em malha aberta. Consequentemente, uma implementação de FWL (\texttt{Step 3}) também não é fornecida. Em seguida, os requisitos desejados são definidos, como $PO_{\mathrm{r}} = 9$, em \texttt{Step 4}, usando um arquivo de especificação \texttt{SpecsFile.ss}.

Dado que a operação em malha aberta foi considerada, este sistema é avaliado com ``\texttt{dsverifier SpecsFile.ss - property OVERSHOOT}'' e, como consequência, ``\texttt{Verification FAILED}'' é retornado, porque o sistema avaliado é instável e, consequentemente, não há sobressinal. Pode-se notar que o método proposto sempre verifica se um sistema é estável.

Como o sistema escolhido é instável, podemos voltar para \texttt{Step 2} e projetar um controlador, a fim de estabilizá-lo e satisfazer o percentual de sobressinal requido ($PO_{\mathrm{r}}$), usando a técnica de Lyapunov~\cite{chen1995linear}. Nesse caso, usamos um controlador $\mathbf{K} = [-0.7351 ~ -5.0045 ~ -18.5371]$ em \texttt{SpecsFile.ss}. Em seguida, executamos esse experimento novamente, mas agora com a opção ``\texttt{---closed-loop}'' e ainda sem efeitos FWL (\texttt{---no-fwl}), o que resulta em \texttt{Verification SUCCESSFUL}, desde que o DSVerifier retornou $PO = 2.6228$ que é menor que $PO_{\mathrm{r}} = 9$.

Finalmente, consideramos os efeitos de FWL nesse experimento. Isso é feito usando o formato $ \langle 4,4 \rangle $, a matriz do controlador $\mathbf{K}_{\mathrm{FWL}} = [-0.6875 ~ -5.0 ~ -18.5] $ e omitindo \texttt{---no-fwl} (\texttt{Step A}), que resulta em ``\texttt{Verification FAILED}'', devido ao fato de o sistema ainda estar instável. Para avaliar outros formatos, $ \langle 8,8 \rangle $ e $ \langle 16,16 \rangle $ foram considerados, em \texttt{Step 2}. Como consequência, $ \langle 8,8 \rangle $ ($\mathbf{K}_{\mathrm{FWL}} = [-0.7344 ~ -5,0039 ~ -18.5352] $) resultou em ``\texttt{Verification SUCCESSFUL}'', dado que o DSVerifier retornou $ PO = 1.6153 $, que é menor que $ PO_{\mathrm{r}} = 9 $ e $ \langle 16,16 \rangle $ ($ \mathbf{K}_{\mathrm{FWL}} = [-0.7351 ~ -5.0045 ~ -18.5370] $) também resultou em ``\texttt{Verification SUCCESSFUL}'', porque nossa metodologia forneceu $ PO = 2.6253 $, que é novamente menor que o valor requerido.

Agora, analisamos nossa abordagem de verificação de tempo de assentamento, seguindo os passos da Figura~\ref{fig:diag1}. Desta forma, \texttt{Step 1} está pronto e \texttt{Step 2} é então considerado, onde uma matriz do controlador $ \mathbf{K} $ não está definida, devido à operação em malha aberta. Consequentemente, uma implementação de FWL (\texttt{Step 3}) também não é fornecida. Em seguida, os requisitos desejados são definidos, ou seja, $ t_{\mathrm{sr}} = 10s $, $ p = 5 $ e $ T_{\mathrm{s}} = 0.5s $, em \texttt{Step 4}, usando um arquivo de especificação \texttt{SpecsFile.ss}.

Finalmente, considerando que a operação em malha aberta foi considerada, este sistema é avaliado com ``\texttt{dsverifier SpecsFile.ss - property SETTLING\_TIME}''. \texttt{Steps A} a \texttt{E} da metodologia proposta são automaticamente executados pelo DSVerifier, considerando uma implementação em malha aberta, e, como consequência, ``\texttt{Verification FAILED}'' é retornado, porque o sistema avaliado é instável, pois seus autovalores são maiores que $ 1 $ ($ \lambda = 1.5 $, devido à Eq.~\eqref{eq:lamb}). Pode-se notar que o método proposto primeiro verifica se um sistema é estável, entre \texttt{Steps A} e \texttt{B}.

Como o sistema escolhido é instável, podemos voltar para o \texttt{Step 2} e projetar um controlador, a fim de estabilizá-lo e satisfazer o tempo de assentamento requerido, usando o Lyapunov~\cite{chen1995linear}. Nesse caso, usamos a mesma matriz do controlador $ \mathbf{K} = [-0.7351 ~ -5.0045 ~ -18.5371] $ em \texttt{SpecsFile.ss}, como explicado em Seção~\ref{subsec:overshootAlg}. Como esse controlador foi projetado para satisfazer ambas as propriedades (tempo de assentamento e sobressinal), esse experimento é executado novamente, mas agora com a opção ``\texttt{---closed-loop}'' e ainda sem efeitos FWL (\texttt{---no-fwl}), que resulta em ``\texttt{Verification SUCCESSFUL}'', como pode ser visto na Figura~\ref{fig:stmethod}(a), onde a resposta ao degrau não deixa a região de assentamento entre $ k_{\mathrm{sr}} $ e $ \hat{k}$.

Finalmente, esse experimento pode considerar os efeitos de FWL. Isso é feito usando o formato $ \langle 4,4 \rangle $, a matriz do controlador $ \mathbf{K}_{\mathrm {FWL}} = [-0.6875 ~ -5.0 ~ -18.5] $ e omitindo \texttt{---no-fwl} (\texttt{Step A}), que resulta em ``\texttt{Verification FAILED}'', como mostrado na Figura~\ref{fig:stmethod}(b), onde o sistema se torna instável. Vale a pena notar que a matriz do controlador $ \mathbf{K} $ em \texttt{SpecsFile.ss} não é modificada e $ \mathbf{K}_{\mathrm {FWL}} $ é internamente calculado pelo DSVerifier.

Para avaliar outros formatos, $ \langle 8,8 \rangle $ e $ \langle 16,16 \rangle $ são considerados em \texttt{Step 2}. Como consequência, $ \mathbf{K}_{\mathrm{FWL}} = [-0.7344 ~ -5.0039 ~ -18.5352] $ com ``\texttt{Verification FAILED}'', porque a resposta ao degrau deixou a região de assentamento entre $ k_{\mathrm{sr}} $ e $ \hat{k} $ e $ \mathbf{K}_{\mathrm{FWL}} = [-0.7351 ~ -5.0045 ~ -18.5370] $ com ``\texttt{Verification SUCCESSFUL}'', porque a resposta ao degrau não deixou a região de assentamento entre $ k_{\mathrm{sr}} $ e $ \hat{k} $, são respectivamente obtidas, como pode ser visto nas Figuras~\ref{fig:stmethod} (c) e (d).


\begin{figure}[ht]
   \centering
   \subfloat{\includegraphics[trim={0.4cm 0cm 3cm 0cm}, clip,width=.45\textwidth]{figures/exDM13cl.eps}}\quad
   \subfloat{\includegraphics[trim={2cm 0cm 3cm 0cm}, clip,width=.45\textwidth]{figures/exDM13cl8b.eps}}\\
   \subfloat{\includegraphics[trim={0.5cm 0cm 3cm 0cm}, clip,width=.45\textwidth]{figures/exDM13cl16b.eps}}\quad
   \subfloat{\includegraphics[trim={0.5cm 0cm 3cm 0cm}, clip,width=.45\textwidth]{figures/exDM13cl32b.eps}}
   \caption{Settling-time verification for the example system, (a) without FWL effects and with formats (b) $\langle 4,4 \rangle$, (c) $\langle 8,8 \rangle$, and (d) $\langle 16,16 \rangle$.
   }
   \label{fig:stmethod}
\end{figure}

O número de bits influencia fortemente os tempos de assentamento em implementações reais, devido a efeitos de FWL. Além disso, ``\texttt{Verification FAILED}'' foi obtido para um formato intermediário $ \langle 8,8 \rangle $, enquanto foi bem sucedido com $ \langle 16,16 \rangle $. De fato, dado que o tempo de assentamento resultante é principalmente dependente da resposta natural mais rápida e sua taxa de amortecimento, a interação entre eles após a quantificação pode causar tal comportamento, o que reforça ainda mais o uso da metodologia proposta, durante fases de projeto.

Pode-se notar também que as propriedades abordadas durante as fases de projeto também são modificadas, devido a mudanças nos coeficientes e nos resultados de cálculo. Em particular, o sobressinal foi afetado de maneiras diferentes, o que significa que, se uma propriedade falhar, a outra talvez não falhe, como pode ser visto no formato $ \langle 8,8 \rangle $.

Pode-se notar que $ t_{\mathrm{sr}} = 10s $ é a amostra $ n = 20 $, discretizada em $ T_{\mathrm{s}} = 0.5s $. A Figura~\ref{fig:stmethod} (a) mostra que $ k_{\mathrm{sr}} = \ceil{t_{\mathrm{sr}} / T_{\mathrm{s}}} = 20 $ é menor que o $\hat{k} = 37 $ calculado (Eq.~\ref{eq:kbar}) e, como consequência, para este tempo de assentamento requerido, o sistema já está na região de assentamento, para que o tempo de assentamento seja possível nesse caso. Finalmente, o mesmo raciocínio é válido para as Figuras~\ref{fig:stmethod} (b), (c) e (d), onde podemos analisar as respostas e verificá-las de acordo com o Algoritmo~\ref{alg:settlingtime}.


%-------------------------------------------------------------------
\section{Síntese de Requisitos de Especificações de Desempenho Não Frágil}
\label{sec:synthesis}
%-------------------------------------------------------------------

Nesta seção, mostramos a metodologia de síntese proposta com base nos requisitos de especificação de desempenho para sistemas de controle digital. Em particular, analisamos as especificações de tempo de assentamento e máximo sobressinal, para sistemas de controle com realimentação de estado digital. A abordagem de síntese proposta, que emprega nossas metodologias de verificação para o máximo tempo de assentamento e máximo sobressinal, como explicado nas seções~\ref{subsec:overshootAlg} e \ref{subsec:settime-alg}, é baseada na técnica de síntese CEGIS, onde são dois estágios: verificação e aprendizado (onde o sintetizador está localizado) como podemos ver no diagrama da Figura~\ref{fig:cegisDiag}. No estágio de aprendizado, geramos um controlador $ \mathbf{K} $ para satisfazer nosso parâmetro requerido (tempo de assentamento e/ou sobressinal), usando algoritmos genéticos~\cite{deb2004introduction}, onde tomamos as definições do sistema e os requisitos como restrições. Depois de gerar o controlador $ \mathbf{K} $, há o estágio de verificação onde ele pega o controlador $ \mathbf{K} $ e verifica se atende aos requisitos, de acordo com nossas metodologias de verificação, e se falhar nessa etapa, ele volta ao estágio de aprendizado e se mantém nesse cciclo, até obter sucesso na verificação ou o sintetizador atingir um número máximo de tentativas.

Na Figura~\ref{fig:SynthArch}, mostramos a arquitetura de síntese proposta de uma forma geral, onde as definições do sistema representam o sistema como um todo (matrizes de espaço de estados, entradas, etc), os requisitos a serem sintetizados, \texttt{total\_attempts} é o número total de tentativas de sintetizar um controlador, \texttt{tentativas} representa o número de tentativas sem alterar qualquer parâmetro de síntese (algoritmo genético), GA é o bloco que realiza a geração de um controlador candidato através de algoritmo genético (\textit{Genetic Algorithms} - GA), \texttt{verify()} é o mecanismo de verificação (Seções~\ref{subsec:overshootAlg} e \ref{subsec:settime-alg}) que dependem do que estamos sintetizando (tempo de assentamento e/ou sobressinal), \texttt{MAXATT} é o número máximo de tentativas de sintetizar um controlador (informado pelo usuário), \texttt{MAXINNERATT} representa o número máximo de tentativas sem alterar nenhum parâmetro do GA, \texttt{popsize} é o tamanho da população do algoritmo genético e \texttt{STEP} é o passo para incrementar a população GA na \textit{engine} de síntese desenvolvida neste trabalho.


\begin{figure}[ht]
\begin{center}
\includegraphics[trim={0.0cm 0.0cm 0.0cm 0cm}, clip,width=0.5\textwidth]{figures/FlowchartArch.eps}
\caption{Proposed synthesis architecture.} 
\label{fig:SynthArch}
\end{center}
\end{figure}

Nossa metodologia de síntese proposta funciona da seguinte maneira. Primeiro definimos o sistema a ser sintetizado (planta, entradas, etc) e os requisitos a serem atendidos (tempo de assentamento/sobressinal), e então escolhemos o que queremos satisfazer no processo de síntese. Além disso, executamos o algoritmo genético usando as restrições necessárias (tempo de assentação e/ou sobressinal), então geramos um controlador candidato $ \mathbf{K} $. Em seguida, realizamos o processo de verificação (de acordo com a propriedade que escolhemos sintetizar); se a verificação for bem sucedida, a síntese é bem sucedida e termina o processo. Caso contrário, a verificação falha e nós verificamos se o número total de tentativas excedeu o número máximo de tentativas, se sim, o processo de síntese falha e termina; caso contrário, verificamos se o número de tentativas, sem mudança qualquer parâmetro do GA, excedeu o número máximo definido para isso, se não voltar a executar o GA novamente (e continuar o processo novamente); caso contrário, incrementamos o tamanho da população do GA, por um passo fixo, e depois disso re-executamos o GA e o processo continua.

%\begin{tikzpicture}[node distance=1cm]
%\node (start) [startstop] {Start};
%\node (in1) [io, below of=start,align=left] {total\_attempts = 0 \\ inner\_attempts = 0};
%\node (proc1) [process, below of=in1] {GA};
%\node (proc2) [io, below of=proc1,align=left] {total\_attempts++ \\ inner\_attempts++};
%\node (dec1) [decision, below of=proc2, yshift=-0.5cm] {Verify};
%\node (dec2) [decision, below of=dec1, yshift=-0.5cm] {total\_attempts > MAX};
%\node (dec3) [decision, below of=dec2, yshift=-0.5cm] {inner\_attempts > MAX2};
%\node (proc3) [process, below of=dec3] {popsize \+\= steppop \\ inner\_attempts = 0};
%%\node (proc2a) [process, below of=dec1, yshift=-0.5cm] {Process 2a};
%%\node (proc2b) [process, below of=dec1, xshift=3cm, yshift=2.3cm] {Process 2b};
%\node (out1) [io, below of=dec1] {Output};
%\node (stop) [startstop, below of=out1] {Stop};
%\draw [arrow] (start) -- (in1);
%\draw [arrow] (in1) -- (proc1);
%\draw [arrow] (proc1) -- (proc2);
%\draw [arrow] (proc2) -- (dec1);
%\draw [arrow] (dec1) -- node[anchor=east] {yes} (out1);
%\draw [arrow] (dec1) -- node[anchor=south] {no} (dec2);
%\draw [arrow] (dec2) -| node[anchor=east] {yes} (out1);
%\draw [arrow] (dec2) -- node[anchor=east] {no} (dec3);
%\draw [arrow] (dec3) -- node[anchor=south] {yes} (proc3);
%\draw [arrow] (dec3) |- node[anchor=west] {yes} (proc1);
%\draw [arrow] (proc3) -- node[anchor=west] {} (proc1);
%\draw [arrow] (out1) -- (stop);
%
%
%
%\end{tikzpicture}



%--------------------------------------------------------------
\subsection{Geração do Controlador Candidato $\mathbf{K}$}
\label{subsec:genK}
%--------------------------------------------------------------

Em nossa metodologia de síntese baseada em CEGIS, usamos algoritmos genéticos para gerar um controlador candidato $ \mathbf{K} $, a fim de satisfazer os requisitos desejados (tempo de assentamento e overshoot). A metodologia usa uma função multi-objetivo para resolver três problemas separados: sintetizar para sobressinal, tempo de assentamento ou ambos. As funções multi-objetivo são:
\begin{equation}
	\label{eq:objfuncSumK}
	\begin{array}{ccc}
		\mathbf{f}_\mathrm{1}(\mathbf{K})=\mathbf{K} \times \mathbf{K}^T\\
	\end{array}
\end{equation}

\noindent and

\begin{equation}
	\label{eq:objfuncST}
	\begin{array}{ccc}
		\mathbf{f}_\mathrm{2}(\mathbf{K})=\hat{k}\\
	\end{array}
\end{equation}

\noindent onde $\mathbf{K}$ é o controlador e $\hat{k}$ é dado por Eq.~\ref{eq:kbar}.

\subsubsection{Problema de Otimização para Sobressinal}
\label{ssubsec:genKover}
Com o objetivo de gerar uma matriz de controlador $ \mathbf{K} $ através de algoritmos genéticos, a fim de satisfazer os requisitos de sobressinal, utilizamos a seguinte formulação do problema.

O problema de otimização consiste em minimizar $\mathbf{f}_\mathrm{1}$ e $\mathbf{f}_\mathrm{2}$ em relação à variável de decisão $ \mathbf{K} $. Assim, o problema de otimização é representado da seguinte forma:
%
\begin{equation}
	\label{eq:optproblemOS}
	\begin{array}{ccc}
		\min & (\mathbf{f}_\mathrm{1}(\mathbf{K}),\mathbf{f}_\mathrm{2}(\mathbf{K})),  \\
  \\
		\textrm{ s.t. } & PO \leq PO_{\mathrm{r}}, \\
                        & \bar{\lambda} \leq 1      
 \\
	\end{array}
\end{equation}

A primeira restrição significa que a porcentagem real de sobressinal deve ser menor que a porcentagem requerida ($ PO_{\mathrm{r}} $). A segunda restrição está relacionada à estabilidade do sistema, onde $ \bar{\lambda} $ é o valor absoluto máximo entre os autovalores do sistema (Seção~\ref{sec:modformver}) e este valor deve ser menor que $1$, caso contrário, o sistema é instável~\cite{chen1995linear}.

\subsubsection{Problema de Otimização para Tempo de Assentamento}
\label{ssubsec:genKst}

Desta vez, queremos otimizar o problema utlizando os requisitos de tempo de assentamento. Para isso, utilizamos amesma função multi-objetivo, onde queremos minimizar $ \mathbf{f}_\mathrm{1} $ e $ \mathbf{f}_\mathrm{2}$ em relação à variável de decisão $ \mathbf{K} $. Assim, o problema de otimização é representado da seguinte forma:
%
\begin{equation}
	\label{eq:optproblemST}
	\begin{array}{ccc}
		\min & (\mathbf{f}_\mathrm{1}(\mathbf{K}),\mathbf{f}_\mathrm{2}(\mathbf{K})),  \\
  \\
		\textrm{ s.t. } & {\hat{k}} \leq k_{\mathrm{sr}}, \\
                        & \bar{\lambda} \leq 1
 \\
	\end{array}
\end{equation}

Neste problema de otimização, a primeira restrição significa que $ \hat{k} $ deve ser menor que o tempo de assentamento requerido em tempo discreto ($ k_{sr} $), porque como podemos ver no Algoritmo~\ref{alg:settlingtime}, quando isso acontece, a verificação é bem sucedida, o que significa que o sistema atende ao máximo tempo de assentamento exigido. A segunda restrição está relacionada à estabilidade do sistema, da mesma forma como mostramos no problema em \ref{ssubsec:genKst}.

\subsubsection{Problema de Otimização para Satisfazer Sobressinal e Tempo de Assentamento}
\label{ssubsec:genKovst}

A fim de gerar um controlador $ \mathbf{K} $ usando algoritmo genético que satisfaça tanto os requisitos de sobressinal quanto de tempo de assentamento, formulamos o seguinte problema de otimização.

\begin{equation}
	\label{eq:optproblemOVST}
	\begin{array}{ccc}
		\min & (\mathbf{f}_\mathrm{1}(\mathbf{K}),\mathbf{f}_\mathrm{2}(\mathbf{K})),  \\
  \\
		\textrm{ s.t. } & {\hat{k}} \leq k_{\mathrm{sr}}, \\
                        & PO \leq PO_{\mathrm{r}}, \\
                        & \bar{\lambda} \leq 1
 \\
	\end{array}
\end{equation}

Neste caso, queremos minimizar as funções multi-objetivo ($ \mathbf{f}_\mathrm{1} $ e $ \mathbf{f}_\mathrm{2} $) restritas a: $ \hat{k} \leq k_\mathrm{sr} $, $ PO \leq PO_{\mathrm{r}} $ e $ \bar{\lambda} \leq 1 $. A primeira restrição garante que o sistema atenda ao requisito de tempo de assentamento, já que $ k_\mathrm{sr} \geq \hat{k} $ (cf. Algoritmo~\ref{alg:settlingtime}). A segunda restrição assegura o percentual máximo de sobressinal exigido (cf. Algoritmo~\ref{alg:overshootReal}). Finalmente, a terceira restrição assegura que o controlador $ \mathbf{K} $ mantenha o sistema estável, considerando que $ \bar{\lambda} $ é o maior valor absoluto entres os autovalores e que este sendo menor que $ 1 $ proporciona estabilidade.

\section{Resumo}\label{chap-4-summary}

Neste capítulo foi apresesentado a metodologia proposta para sintetizar controladores digitais satisfazendo restrições de especificação de desempenho da resposta ao degrau,c onsiderando os efeitos de FWL, sendo esta a contribuição maior do presente trabalho. Foi dada uma explicação detalhada de todo o processo de síntese a qual foi baseada na técnica de CEGIS. A técnica de síntese empregada neste trabalha possui uma etapa de verificação, onde mostramos a metodologia que criamos para fazer a devida verificação de especificações de desemprenho (máximo sobressinal e máximo tempo de assentamento). Mostrou-se também um exemplo prático do funcionamento dos verificadores aplicado ao sistema de controle do mundo real. Por fim, mostrou-se como foi idealizada a etapa de síntese, onde modelamos nosso problema como um problema de otimização e utlizamos algoritmo genético para resolver. Como resultado, tem-se o embasamento para a avaliação experimental realizada no próximo capítulo.
